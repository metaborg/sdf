module generate-stratego

imports
  libstratego-lib
  libstrc
  analysis/types
  runtime/nabl/-
  runtime/task/-
  runtime/types/-
  generation/gen-utils/to-str
  analysis/desugar

imports
  common
  utils

imports
  signatures/aliases/-
  signatures/aterms/-
  signatures/basic/-
  signatures/characterclass/-
  signatures/constants/-
  signatures/grammar/-
  signatures/kernel/-
  signatures/labels/-
  signatures/layout/-
  signatures/layout-constraints/-
  signatures/lifting/-
  signatures/literals/-
  signatures/modules/-
  signatures/priority/-
  signatures/regular/-
  signatures/renaming/-
  signatures/restrictions/-
  signatures/sdf2-core/-
  signatures/sorts/-
  signatures/symbols/-
  signatures/TemplateLang-sig

rules

  // geninj-generate-stratego :: SDF3.Module -> Stratego.Module
  geninj-generate-stratego = strip-annos; geninj-module-to-injections

  // Generate Stratego strategies and rules for explicating and implicating injections
  // geninj-module-to-injections :: SDF3.Module -> Stratego.Module
  geninj-module-to-injections:
    Module(modname, imports, sections) -> Module(modname', [
      imports0,
      imports1*,
      Signature([Constructors(signatures)]),
      Rules(sort-is-rules),
      Rules(sig-is-rules),
      Rules(sort-expl-rules),
      Rules(sig-expl-rules),
      Rules(sort-impl-rules),
      Rules(sig-impl-rules),
      Rules(expl-plhdr-rules),
      Rules(impl-plhdr-rules)
    ])
  with modname'         := <to-str-module-name(|"-injections", "injections")> Module(modname)
     ; lang := <language-spec-name>
     // Imports
     ; imports0         := Imports([
         Import(<to-str-module-name(|"-sig","signatures")> Module(modname)),
         Import(<to-str-module-name(|"-pp","pp")> Module(modname))
       ])
     ; imports1*        := <map(to-str-import(|"-injections", "injections"))> imports
     // Collect CF and LEX sorts
     ; allsorts         := <geninj-sections-to-sorts> sections
     // Collect signatures
     ; allsigs          := <geninj-sections-to-signatures> sections
     // Stratego signatures
     ; signatures       := <filter(geninj-sig-to-strsig)> allsigs
     // Stratego rules and strategies
     ; sort-expl-rules  := <flatfilter(geninj-sort-to-lang-explication-rule(|lang))> allsorts
     ; sort-impl-rules  := <flatfilter(geninj-sort-to-lang-implication-rule(|lang))> allsorts
     ; sort-is-rules    := <flatfilter(geninj-sort-to-is-rule(|lang))> allsorts
     ; expl-plhdr-rules := <flatfilter(geninj-sort-to-explicate-placeholder-rule(|lang))> allsorts
     ; impl-plhdr-rules := <flatfilter(geninj-sort-to-implicate-placeholder-rule(|lang))> allsorts
     ; sig-expl-rules   := <flatfilter(geninj-sig-to-explication-rule(|lang))> allsigs
     ; sig-impl-rules   := <flatfilter(geninj-sig-to-implication-rule(|lang))> allsigs
     ; sig-is-rules     := <flatfilter(geninj-sig-to-is-rule(|lang))> allsigs

rules

  // geninj-lex-inj-to-is-rule :: ExtSort -> Stratego.?
  geninj-lexsort-to-is-rule(|lang): LexSort(sortname)
  -> SDefNoArgs($[is-[lang]-[sortname]-or-inj], CallNoArgs(SVar($[is-string])))


rules

  geninj-sort-to-lang-explication-rule(|lang): CfSort(sortname) ->
    // explicate-injections-MyLang = explicate-injections-MyLang-MySort
    SDefNoArgs($[explicate-injections-[lang]], CallNoArgs(SVar($[explicate-injections-[lang]-[sortname]])))
  geninj-sort-to-lang-implication-rule(|lang): CfSort(sortname) ->
    // implicate-injections-MyLang = implicate-injections-MyLang-MySort
    SDefNoArgs($[implicate-injections-[lang]], CallNoArgs(SVar($[implicate-injections-[lang]-[sortname]])))

  geninj-sort-to-explicate-placeholder-rule(|lang): CfSort(sortname) ->
    // explicate-injections-MyLang-MySort: MySort-Plhdr() -> MySort-Plhdr()
    RDefNoArgs($[explicate-injections-[lang]-[sortname]], RuleNoCond(
      NoAnnoList(Op($[[sortname]-Plhdr], []))
    , NoAnnoList(Op($[[sortname]-Plhdr], []))
    ))
  geninj-sort-to-implicate-placeholder-rule(|lang): CfSort(sortname) ->
    // implicate-injections-MyLang-MySort: MySort-Plhdr() -> MySort-Plhdr()
    RDefNoArgs($[implicate-injections-[lang]-[sortname]], RuleNoCond(
      NoAnnoList(Op($[[sortname]-Plhdr], []))
    , NoAnnoList(Op($[[sortname]-Plhdr], []))
    ))

rules

  geninj-sort-to-explication-rule(|lang): LexSort(sortname) ->
    // explicate-injections-MyLang-MySort: t -> t
    RDefNoArgs($[explicate-injections-[lang]-[sortname]], RuleNoCond(Var("t"), Var("t")))
  geninj-sort-to-implication-rule(|lang): LexSort(sortname) ->
    // implicate-injections-MyLang-MySort: t -> t
    RDefNoArgs($[implicate-injections-[lang]-[sortname]], RuleNoCond(Var("t"), Var("t")))
  geninj-sort-to-is-rule(|lang): LexSort(sortname) ->
    // is-MyLang-MySort-or-inj = is-string
    SDefNoArgs($[is-[lang]-[sortname]-or-inj], CallNoArgs(SVar($[is-string])))


rules

  geninj-sig-to-strsig: CfSignature(sortname, None(), params) ->
    OpDecl(consname, FunType(str-paramsigs, ConstType(SortNoArgs(sortname))))
  with str-paramsigs := <map(geninj-param-to-strsig)> params
     ; consname  := <geninj-generate-inj-name> (sortname, params)

  geninj-param-to-strsig: Param(symbol, _) -> <geninj-symbol-to-strsig> symbol

  geninj-symbol-to-strsig: Sort(name)           -> ConstType(SortNoArgs(name))
  geninj-symbol-to-strsig: Opt(sort)            -> ConstType(<geninj-symbol-to-strsig> sort)
  geninj-symbol-to-strsig: Iter(sort)           -> ConstType(Sort("List", [<geninj-symbol-to-strsig> sort]))
  geninj-symbol-to-strsig: IterSep(sort, _)     -> ConstType(Sort("List", [<geninj-symbol-to-strsig> sort]))
  geninj-symbol-to-strsig: IterStar(sort)       -> ConstType(Sort("List", [<geninj-symbol-to-strsig> sort]))
  geninj-symbol-to-strsig: IterStarSep(sort, _) -> ConstType(Sort("List", [<geninj-symbol-to-strsig> sort]))
  geninj-symbol-to-strsig: Cf(sort)             -> <geninj-symbol-to-strsig> sort
  geninj-symbol-to-strsig: Lex(sort)            -> <geninj-symbol-to-strsig> sort
  geninj-symbol-to-strsig: Var(sort)            -> <geninj-symbol-to-strsig> sort

rules

  geninj-sig-to-explication-rule(|lang): CfSignature(sortname, None(), [param@Param(tosort, varname)]) ->
    // explicate-injections-MyLang-MySort: t -> ToSort2MySort(<explicate-injections-MyLang-ToSort> t)
    //   where <is-MyLang-MySort-or-inj> t
    RDefNoArgs($[explicate-injections-[lang]-[sortname]], Rule(
      Var(varname), NoAnnoList(Op(consname, [expl-call]))
    , BA(is-call, Var(varname))
    ))
  with consname   := <geninj-generate-inj-name> (sortname, [param])
     ; expl-call  := <geninj-param-to-explication-call(|lang)> param
     ; is-call    := <geninj-symbol-to-is-call(|lang)> tosort

  geninj-sig-to-implication-rule(|lang): CfSignature(sortname, None(), [param@Param(tosort, varname)]) ->
    // implicate-injections-MyLang-MySort: ToSort2MySort(t) -> <implicate-injections-MyLang-ToSort> t
    RDefNoArgs($[implicate-injections-[lang]-[sortname]], RuleNoCond(
      NoAnnoList(Op(consname, [Var(varname)])),
      impl-call
    ))
  with consname   := <geninj-generate-inj-name> (sortname, [param])
     ; impl-call  := <geninj-param-to-implication-call(|lang)> param

  geninj-sig-to-is-rule(|lang): CfSignature(sortname, None(), [param@Param(tosort, _)]) ->
    SDefNoArgs($[is-[lang]-[sortname]-or-inj], is-call)
  with consname   := <geninj-generate-inj-name> (sortname, [param])
     ; is-call    := <geninj-symbol-to-is-call(|lang)> tosort


rules

  geninj-sig-to-explication-rule(|lang): CfSignature(sortname, Some(consname), params) ->
    // explicate-injections-MyLang-MySort: MyCons(t) -> MyCons(<explicate-injections-MyLang-SubSort> t)
    RDefNoArgs($[explicate-injections-[lang]-[sortname]], RuleNoCond(
      NoAnnoList(Op(consname, vars))
    , NoAnnoList(Op(consname, ops))
    ))
  with vars := <geninj-params-to-vars> params
     ; ops  := <geninj-params-to-explication-calls(|lang)> params

  geninj-sig-to-implication-rule(|lang): CfSignature(sortname, Some(consname), params) ->
    // implicate-injections-MyLang-MySort: MyCons(t) -> MyCons(<implicate-injections-MyLang-SubSort> t)
    RDefNoArgs($[implicate-injections-[lang]-[sortname]], RuleNoCond(
      NoAnnoList(Op(consname, vars))
    , NoAnnoList(Op(consname, ops))
    ))
  with vars := <geninj-params-to-vars> params
     ; ops  := <geninj-params-to-implication-calls(|lang)> params

  geninj-sig-to-is-rule(|lang): CfSignature(sortname, Some(consname), params) ->
    // is-MyLang-MySort-or-inj = ?MyCons(_)
    SDefNoArgs(
      $[is-[lang]-[sortname]-or-inj]
    , Match(NoAnnoList(Op(consname, args)))
    )
  with args := <map(!Wld())> params



rules

  geninj-params-to-vars = map(geninj-param-to-var)
  geninj-param-to-var: Param(_, newname) -> Var(newname)

  geninj-params-to-explication-calls(|lang) = map(geninj-param-to-explication-call(|lang))
  geninj-param-to-explication-call(|lang): Param(symbol, newname) -> App(<geninj-symbol-to-explication-call(|lang)> symbol, Var(newname))

  geninj-symbol-to-explication-call(|lang): Sort(name)            -> CallNoArgs(SVar($[explicate-injections-[lang]-[name]]))
  geninj-symbol-to-explication-call(|lang): Opt(sort)             -> Call(SVar("map"), [<geninj-symbol-to-explication-call(|lang)> sort])
  geninj-symbol-to-explication-call(|lang): Iter(sort)            -> Call(SVar("map"), [<geninj-symbol-to-explication-call(|lang)> sort])
  geninj-symbol-to-explication-call(|lang): IterSep(sort, _)      -> Call(SVar("map"), [<geninj-symbol-to-explication-call(|lang)> sort])
  geninj-symbol-to-explication-call(|lang): IterStar(sort)        -> Call(SVar("map"), [<geninj-symbol-to-explication-call(|lang)> sort])
  geninj-symbol-to-explication-call(|lang): IterStarSep(sort, _)  -> Call(SVar("map"), [<geninj-symbol-to-explication-call(|lang)> sort])
  geninj-symbol-to-explication-call(|lang): Cf(sort)              -> <geninj-symbol-to-explication-call(|lang)> sort
  geninj-symbol-to-explication-call(|lang): Lex(sort)             -> <geninj-symbol-to-explication-call(|lang)> sort
  geninj-symbol-to-explication-call(|lang): Var(sort)             -> <geninj-symbol-to-explication-call(|lang)> sort

rules

  geninj-params-to-implication-calls(|lang) = map(geninj-param-to-implication-call(|lang))
  geninj-param-to-implication-call(|lang): Param(symbol, newname) -> App(<geninj-symbol-to-implication-call(|lang)> symbol, Var(newname))

  geninj-symbol-to-implication-call(|lang): Sort(name)            -> CallNoArgs(SVar($[implicate-injections-[lang]-[name]]))
  geninj-symbol-to-implication-call(|lang): Opt(sort)             -> Call(SVar("map"), [<geninj-symbol-to-implication-call(|lang)> sort])
  geninj-symbol-to-implication-call(|lang): Iter(sort)            -> Call(SVar("map"), [<geninj-symbol-to-implication-call(|lang)> sort])
  geninj-symbol-to-implication-call(|lang): IterSep(sort, _)      -> Call(SVar("map"), [<geninj-symbol-to-implication-call(|lang)> sort])
  geninj-symbol-to-implication-call(|lang): IterStar(sort)        -> Call(SVar("map"), [<geninj-symbol-to-implication-call(|lang)> sort])
  geninj-symbol-to-implication-call(|lang): IterStarSep(sort, _)  -> Call(SVar("map"), [<geninj-symbol-to-implication-call(|lang)> sort])
  geninj-symbol-to-implication-call(|lang): Cf(sort)              -> <geninj-symbol-to-implication-call(|lang)> sort
  geninj-symbol-to-implication-call(|lang): Lex(sort)             -> <geninj-symbol-to-implication-call(|lang)> sort
  geninj-symbol-to-implication-call(|lang): Var(sort)             -> <geninj-symbol-to-implication-call(|lang)> sort


rules

  geninj-symbol-to-is-call(|lang): Sort(name)                     -> CallNoArgs(SVar($[is-[lang]-[name]-or-inj]))
  geninj-symbol-to-is-call(|lang): Opt(name)                      -> <fail>
  geninj-symbol-to-is-call(|lang): Iter(sort)                     -> <geninj-symbol-to-is-call-list(|lang)> sort
  geninj-symbol-to-is-call(|lang): IterSep(sort, _)               -> <geninj-symbol-to-is-call-list(|lang)> sort
  geninj-symbol-to-is-call(|lang): IterStar(sort)                 -> <geninj-symbol-to-is-call-list(|lang)> sort
  geninj-symbol-to-is-call(|lang): IterStarSep(sort, _)           -> <geninj-symbol-to-is-call-list(|lang)> sort
  geninj-symbol-to-is-call(|lang): Cf(sort)                       -> <geninj-symbol-to-is-call-list(|lang)> sort
  geninj-symbol-to-is-call(|lang): Lex(sort)                      -> <geninj-symbol-to-is-call-list(|lang)> sort
  geninj-symbol-to-is-call(|lang): Var(sort)                      -> <geninj-symbol-to-is-call-list(|lang)> sort

  geninj-symbol-to-is-call-list(|lang): nestedSort ->
    // is-list; map(is-MySort-or-inj)
    Seq(CallNoArgs(SVar("is-list")), Call(SVar("map"), [<geninj-symbol-to-is-call(|lang)> nestedSort]))


