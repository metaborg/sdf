module generation/to-formatted

imports
	analysis/-
	runtime/index/-
 	runtime/task/-
 	include/TemplateLang-sig
 	lib/runtime/nabl/-
  	lib/runtime/properties/-
  	analysis/names
  	trans/utils/tokenize
  

rules
    sugar-priorities:
    	SimpleGroup(prod) ->  SimpleRefGroup(sc)
    where
    	sortdef 	:= <?SdfProduction(SortDef(<id>), Rhs(rhs), _)> prod;
    	rhs'        := <topdown(try(strip-annos))> rhs;
    	const  		:= <get-properties(|NablProp_constructorName())> sortdef;
    	temps*  	:= <map(get-def); try(desugar-templates); topdown(try(strip-annos))> const;
    	p*          := <map(get-prod-elems)> temps*;
        [sc]	 	:= <filter(?(<id>, rhs'))> p*
    
    
    get-prod-elems:
  	SdfProductionWithCons(SortCons(SortDef(s),c), Rhs(symbols*), a*) -> (SortConsRef(Sort(s), c), symbols*)		
  	
    get-prod-elems:
  	TemplateProductionWithCons(SortCons(SortDef(s),c), t, a) -> (SortConsRef(Sort(s), c), result)
  	with
  		result := <template-to-prod> t
    
    
    	
    	
    remove-attrs:
    	SdfProductionWithCons(sc, rhs, attrs) -> SdfProductionWithCons(sc, rhs, NoAttrs()) 
    
    //single-line template
  template-to-prod:
  	SingleLineTemplate(elems) -> elems'
  	with
  	elems' := <filter(template-elem-to-prod); flatten-list> elems
  	
  template-elem-to-prod:
  	String(t) -> <string-to-prod> t
  
  //removing layout from separator	
  template-elem-to-prod:
  	Placeholder(symbol, option) -> symbol' 
  	where
  		<?IterSep(_, Lit(lit)) + ?IterStarSep(_, Lit(lit)) + ?Label(_, IterSep(_, Lit(lit))) + ?Label(_, IterStarSep(_, Lit(lit)))> symbol
  	with
  		lit' := <separator-to-literal> lit;
  		//debug(!"lit' = ");
  		if "" := lit'
  		then
  			switch !symbol
	  			case ?IterSep(sym, _) : symbol' :=  Iter(sym)
	  			case ?IterStarSep(sym, _) : symbol' :=  IterStar(sym)
	  			case ?Label(l, IterSep(sym, _)) : symbol' :=  Label(l, Iter(sym))
	  			case ?Label(l, IterStarSep(sym, _)) : symbol' :=  Label(l, IterStar(sym))
  			end
  		else	
	  		switch !symbol
	  			case ?IterSep(sym, _) : symbol' :=  IterSep(sym, Lit(lit'))
	  			case ?IterStarSep(sym, _) : symbol' :=  IterStarSep(sym, Lit(lit'))
	  			case ?Label(l, IterSep(sym, _)) : symbol' :=  Label(l, IterSep(sym, Lit(lit')))
	  			case ?Label(l, IterStarSep(sym, _)) : symbol' :=  Label(l, IterStarSep(sym, Lit(lit')))
	  		end
	  	end	
  		
  template-elem-to-prod:
  	Placeholder(symbol, option) -> symbol
  	where
  		<not(?IterSep(_, Lit(lit)) + ?IterStarSep(_, Lit(lit)) + ?Label(_, IterSep(_, Lit(lit))) + ?Label(_, IterStarSep(_, Lit(lit))))> symbol
  
  	
  //multi-line template
  template-to-prod:
     Template(lines) -> elems
     with
     	elems := <map(line-to-prod)> lines
   
 line-to-prod:
  	Line(elems) -> elems'
  	with
  		elems' := <filter(template-elem-to-prod); flatten-list> elems	
 
string-to-prod =  string-edge-tokenize(where({x: ?x; <one(?x)> ['(', ')']})); map(!Lit(<template-escape; double-quote>))
 
 
 char-is-layout =
    ' ' + '\t' + '\r' + '\n'

  string-is-layout =
    string-as-chars(all(char-is-layout))

  remove-layout =
    string-as-chars(filter(not(char-is-layout)))

  separator-to-literal = un-double-quote; unescape; remove-layout; template-escape
  		
 template-escape =
    string-replace(|"\\", "\\\\");
    string-replace(|"\t", "\\t");
    string-replace(|"\r", "\\r");
    string-replace(|"\n", "\\n");
    //string-replace(|"'", "\\'");
    string-replace(|"\"", "\\\"") 		
  		