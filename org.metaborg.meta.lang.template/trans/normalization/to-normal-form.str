module normalization/to-normal-form

imports 
  libstratego-sglr
  libspoofax/resource/cache
  signatures/TemplateLang-sig
  analysis/desugar
  analysis/attributes
  analysis/lifting
  generation/gen-utils/remove-template
  names/analysis/names
  runtime/analysis/core
  editor/build-utils  
  pp/layout-constraints/Layout-Constraints-pp
  libstratego-gpp
  utils/tokenize

imports
  signatures/aliases/-
  signatures/aterms/-
  signatures/basic/-
  signatures/characterclass/-
  signatures/constants/-
  signatures/grammar/-
  signatures/kernel/-
  signatures/labels/-
  signatures/layout/-
  signatures/layout-constraints/-
  signatures/lifting/-
  signatures/literals/-
  signatures/modules/-
  signatures/priority/-
  signatures/regular/-
  signatures/renaming/-
  signatures/restrictions/-
  signatures/sdf2-core/-
  signatures/sorts/-
  signatures/symbols/-
  signatures/TemplateLang-sig
  
rules

    cputime = prim("SSL_cputime")
    
    cputime-to-seconds:
        cputime -> <div> (cputime, 1000000000)
    
    measure-time(s, match) =
        where(before := <cputime>);
        s;
        where(after := <cputime>; !(after, before); subt; match)    
        
rules 
    placeholder-chars = prim("SSL_EXT_placeholder_chars") <+ ("[[", "]]")    
  
rules
    
    // m[def](m) is missing here. Basically expand imports for a determined top module (current one?)
    to-normal-form(|path) = module-to-normal-form(|path)
    
    module-to-normal-form(|path) = module-to-normal-form
    
    module-to-normal-form:
        m@Module(Unparameterized(mn), i*, sections*) -> <bottomup(try(strip-annos); try(replace-sort-def))> Module(Unparameterized($[normalized/[mn]-norm]), imports, new-sections)
        with
            //<debug(!"normalizing grammar ")> mn;
            mn'  := <strip-annos> mn;
            rules(expanded-module: mn' -> <id>);
            where(before-normalizing := <cputime>);
            
            //TODO: Only one tokenize section works per file, have proper granularity for this
            tokenize-chars             := <collect-one(?Tokenize(<id; explode-string; un-double-quote-chars>)) <+ !['(', ')']> sections*;
            kfr                        := <collect-one(?KeywordFollowRestriction(<id>)) <+ !None()> sections*;
            kattrs                     := <collect-one(?KeywordAttributes(_, _)) <+ !None()> sections*;
            
            desugared-sections*        := <lift-all; desugar-templates; desugar-layout-constraints(|tokenize-chars)> sections*;
            new-lex-restrictions*      := <generate-follow-restrictions-reject-keywords(|kfr, tokenize-chars, kattrs)> desugared-sections*;
            non-template-sections*     := <remove-templates(|tokenize-chars); topdown(try(sugar-attributes))> [desugared-sections*, new-lex-restrictions*];
            
            non-template-sections'*    := <flatten-list> [non-template-sections*, <filter(add-placeholder-prods)> non-template-sections*];
                       
            import-names*              := <collect(?Module(Unparameterized(<id>))); map(!Module(Unparameterized(<concat-strings>["normalized/", <id>, "-norm"])))> i*;
            imports                    := <?[] <+ ![Imports(<id>)]> import-names*;
            
            // keeping Sort.Cons in the normalized grammar
            // lifted-cons    := <lift-constructors-norm> non-template-m;
            
//             where(before-normalizing-exp-prio := <cputime>);
            // change priority norm to handle Sort.Cons priorities
//            expanded-prio              := <expand-priorities(|tokenize-chars)> non-template-sections'*;            
//            after-normalizing-exp-prio := <cputime>;
            
//            where(!(after-normalizing-exp-prio, before-normalizing-exp-prio); subt; cputime-to-seconds; ?total-time-exp-prio; <debug(!"time spent expanding priorities ")> (<strip-annos> mn, total-time-exp-prio))
            
            where(before-normalizing-basic := <cputime>);
            //basic normalization
            new-basic-prods'*          := <filter(basic-norm-aux(|tokenize-chars)); flatten-list> non-template-sections'*;
            new-basic-prods*           := [new-basic-prods'*, SdfProduction(Cf(Layout()), Rhs([Cf(Layout()), Cf(Layout())]), Attrs([Assoc(Left())]))];
            new-basic-priorities*      := <filter(basic-norm-aux-prio(|tokenize-chars)); flatten-list> non-template-sections'*;
            after-normalizing-basic := <cputime>;
            
//            where(!(after-normalizing-basic, before-normalizing-basic); subt; cputime-to-seconds; ?total-time-basic; <debug(!"time spent basic normalization (-cf, -lex) ")> (<strip-annos> mn, total-time-basic))
            
           
            where(before-normalizing-rest := <cputime>);
            // basic + restrictions
            cf-restrictions*           := <filter(?SDFSection(ContextFreeRestrictions(<id>))); flatten-list; map(try(cf-to-kernel-restriction))> non-template-sections'*;
            lex-restrictions*          := <filter(?SDFSection(LexicalRestrictions(<id>))); flatten-list; map(try(lex-to-kernel-restriction))> non-template-sections'*;
            kernel-restrictions*       := <filter(?SDFSection(Restrictions(<id>))); flatten-list> non-template-sections'*;
            after-normalizing-rest := <cputime>;
      
//            where(!(after-normalizing-rest, before-normalizing-rest); subt; cputime-to-seconds; ?total-time-rest; <debug(!"time spent normalizing restrictions ")> (<strip-annos> mn, total-time-rest))
            
      
            where(before-normalizing-top-sorts := <cputime>);
            // top sorts
            lex-start-symbols*         := <filter(?SDFSection(LexicalStartSymbols(<id>))); flatten-list> non-template-sections'*;
            cf-start-symbols*          := <filter(?SDFSection(ContextFreeStartSymbols(<id>))); flatten-list> non-template-sections'*;
            start-symbols*             := <filter(?SDFSection(KernelStartSymbols(<id>))); flatten-list> non-template-sections'*; 
            lexical-start-prods*       := <map(lex-start-prod)> lex-start-symbols*;
            start-prods*               := <map(kernel-start-prod)> start-symbols*;
            cf-start-prods*            := <map(cf-start-prod)> cf-start-symbols*;
            new-top-sorts-prods*       := [lexical-start-prods*, start-prods*, cf-start-prods*, SdfProduction(FileStart(), Rhs([Start(), CharClass(Simple(Present(Numeric("\\256"))))]), NoAttrs())];
            after-normalizing-top-sorts := <cputime>;
            
//            where(!(after-normalizing-top-sorts, before-normalizing-top-sorts); subt; cputime-to-seconds; ?total-time-top-sorts; <debug(!"time spent top sorts ")> (<strip-annos> mn, total-time-top-sorts))
            
            
            where(before-normalizing-reg := <cputime>);
            // regular 
            cf-symbols*                := <bagof-get-cf-sorts; make-set> "cf-symbols";
            lex-symbols*               := <bagof-get-lexical-sorts; make-set> "lexical-symbols";
            kernel-symbols*            := <bagof-get-kernel-sorts; make-set> "kernel-symbols";
            new-regular-prods*         := <filter(regular-norm-symbol); flatten-list> [cf-symbols*, lex-symbols*, kernel-symbols*];

            new-lex-symbols*           := <bagof-get-lexical-sorts; make-set> "new-lexical-symbols";
//            new-regular-priorities*    := <filter(regular-norm-symbol-prio); flatten-list>  [cf-symbols*, lex-symbols*, new-lex-symbols*, kernel-symbols*];
            after-normalizing-reg := <cputime>;
            
//            where(!(after-normalizing-reg, before-normalizing-reg); subt; cputime-to-seconds; ?total-time-reg; <debug(!"time spent normalizing regular expressions ")> (<strip-annos> mn, total-time-reg))
            
            
            where(before-normalizing-prio := <cputime>);
            // priorities

            new-kernel-priorities*      := <map(try(norm-prio-fun(|tokenize-chars))); flatten-list> [new-basic-priorities*];//, new-regular-priorities*];            
            assoc-prio-from-prods*      := <filter(assoc-prio-fun); flatten-list> [new-regular-prods*, new-basic-prods*, new-top-sorts-prods*];       
            new-normalized-priorities*  := <topdown(try(norm-prio-args(|tokenize-chars)))> [new-kernel-priorities*, assoc-prio-from-prods*];
            after-normalizing-prio := <cputime>;            
//            where(!(after-normalizing-prio, before-normalizing-prio); subt; cputime-to-seconds; ?total-time-prio; <debug(!"time spent normalizing priorities ")> (<strip-annos> mn, total-time-prio))
           
            
            where(before-normalizing-lit := <cputime>);
            // literals            
            literals*                  := <collect(?Lit(_) + ?CiLit(_)); make-set> [new-regular-prods*, new-basic-prods*, new-top-sorts-prods*];
            new-literal-prods*         := <map(make-prod-from-lit)> literals*;
            after-normalizing-lit := <cputime>;        
           
//            where(!(after-normalizing-lit, before-normalizing-lit); subt; cputime-to-seconds; ?total-time-lit; <debug(!"time spent normalizing literals ")> (<strip-annos> mn, total-time-lit))
            
            
            where(before-normalizing-cc := <cputime>);        
            // char-class
            new-char-class-prio*       := <topdown(try(character-norm-fun)); bottomup(try(pre-char-class-norm)); char-class-norm-fun; bottomup(try(cc-set-operations))> new-normalized-priorities*;
            new-char-class-prods*      := <topdown(try(character-norm-fun)); bottomup(try(pre-char-class-norm)); char-class-norm-fun; bottomup(try(cc-set-operations))> [new-literal-prods*, new-regular-prods*, new-basic-prods*, new-top-sorts-prods*];
            new-char-class-restr*      := <topdown(try(character-norm-fun)); bottomup(try(pre-char-class-norm)); char-class-norm-fun; bottomup(try(cc-set-operations))> [cf-restrictions*, lex-restrictions*, kernel-restrictions*];
            after-normalizing-cc := <cputime>;            
            
//            where(!(after-normalizing-cc, before-normalizing-cc); subt; cputime-to-seconds; ?total-time-cc; <debug(!"time spent normalizing character classes ")> (<strip-annos> mn, total-time-cc));
           
            
            new-priorities-section     := SDFSection(Priorities(<make-set> [new-char-class-prio*]));
            // TODO: proper merge of productions (same production = merge attributes)
            new-kernel-section         := SDFSection(Kernel(<make-set> [new-char-class-prods*]));
            
            // restrictions
            new-restrictions-section   := SDFSection(Restrictions(<merge-restrictions; make-set> [new-char-class-restr*])); //SDFSection(Restrictions(<merge-restrictions> new-char-class-restr*))
            
            if <?SDFSection(Restrictions([]))> new-restrictions-section then
                new-sections := [new-kernel-section, new-priorities-section]
            else
                new-sections := [new-kernel-section, new-restrictions-section, new-priorities-section]
            end 
            
//            ;after-normalizing := <cputime>; 
            
//            where(!(after-normalizing, before-normalizing); subt; cputime-to-seconds; ?total-time; <debug(!"time spent normalizing grammar ")> (<strip-annos> mn, total-time))
    
  add-placeholder-prods:
    SDFSection(ContextFreeSyntax(prods*)) -> SDFSection(ContextFreeSyntax([placeholder-prods*]))
    with
      //content completion prods
        sorts*                 := < collect(?SortDef(<strip-annos>) <+ ?Sort(<strip-annos>))
                                  ; nub> prods*;
        placeholder-prods*     := <map(add-plhdr-prod)> sorts*
   
  add-plhdr-prod:
    s -> SdfProductionWithCons(SortCons(SortDef(s), Constructor(c)), Rhs([rhs]), Attrs([Placeholder()]))
      with
        placeholder-chars := <placeholder-chars> ;
        left-placeholder-chars := <?(<id>, _)> placeholder-chars;
        right-placeholder-chars := <?(_, <id>)> placeholder-chars;
        rhs := Lit(<concat-strings; double-quote> [left-placeholder-chars, s, right-placeholder-chars]);
        c := $[[s]-Plhdr]  
  
  
  normalize-layout-constraints = topdown(try(normalize-constraint))
  
  normalize-constraint :
    LayoutConstraint(constr) -> Term(Default(Appl(Unquoted("layout"), [Fun(Quoted($["[<prettyprint-TemplateLang-Constraint; !V([], <id>); box2text-string(|120)> constr]"]))])))
  
  generate-follow-restrictions-reject-keywords(|kfr, chars, kattrs) = filter(follow-restrictions-template-prods(|kfr, chars, kattrs)); flatten-list
  
  follow-restrictions-template-prods(|kfr, chars, kattrs):
    SDFSection(ContextFreeSyntax(prods*)) -> [restr*, plhd-restr*, SDFSection(LexicalSyntax(reject-prods*))]
      where 
      // lexical restrictions for placeholders
      prods' := <map(prod-to-sdf <+ prod-to-sdf(|chars, None()))> prods*;
      // explicit placeholder prods
      sorts*     := < collect(?SortDef(<strip-annos>) <+ ?Sort(<strip-annos>))
                        ; nub> prods*;      
      if [] := sorts* then
              plhdr-restr* := []
          else
              (left-placeholder-chars, right-placeholder-chars) := <placeholder-chars>;
              plhd-restr* := [SDFSection(LexicalRestrictions([Follow(<map(!Lit(<concat-strings; double-quote> [left-placeholder-chars, <id>, right-placeholder-chars]))> sorts*, 
                                                                        Single(CharClass(Simple(Present(
                                                                                       Conc(Range(Short("a"), Short("z"))
                                                                                          , Range(Short("A"), Short("Z"))))))))]))]
          end;                                                                                     
      // lexical restrictions
        x    := <filter(case-sensitive-template-prods); nub> prods*;
        ci-x := <filter(case-insensitive-template-prods); nub> prods*;
        let
          chars-end-with-identifier-char =
                where(reverse; ?[<is-alphanum + '_'> | _])
  
              string-ends-with-identifier-char =
                where(explode-string; chars-end-with-identifier-char)
        in
          r* := <collect-om(?String(<string-edge-tokenize(where({x: ?x; <one(?x)> chars}))>));
             flatten-list;
                 filter(string-ends-with-identifier-char; string-to-norm(|chars); last)> x;
          ci-r* := <collect-om(?String(<string-edge-tokenize(where({ci-x: ?ci-x; <one(?ci-x)> chars}))>));
             flatten-list;
                 filter(string-ends-with-identifier-char; string-to-norm-insensitive(|chars); last)> ci-x;       
            if ![ci-r*, r*] => [] + !kfr => None() then
              restr* := []
            else
              restr* := [SDFSection(LexicalRestrictions([Follow(<nub> [ci-r*, r*], kfr)]))]
            end
        end;
        // reject/other attributes productions
        if ![ci-r*, r*] => [] + !kattrs => None() then
           reject-prods* := []
        else
           <?KeywordAttributes(symbol-kattrs, attr-kattrs)> kattrs;
           reject-prods* := <nub; map(!SdfProduction(symbol-kattrs, Rhs([<id>]), attr-kattrs))> [ci-r*, r*]
        end
 
 
  string-to-norm(|chars) =
    string-edge-tokenize(where({x: ?x; <one(?x)> chars}));
    //debug(!"stringtosdf");
    // FIXME: Case insensitive literals need ci-lit/single-quote.
    map(!Lit(<escape-sdf3; double-quote>))

  string-to-norm-insensitive(|chars) =
    string-edge-tokenize(where({x: ?x; <one(?x)> chars}));
    //debug(!"stringtosdf");
    map(!CiLit(<escape-sdf3; single-quote>))

  escape-sdf3 =
    string-replace(|"\\", "\\\\");
    string-replace(|"\t", "\\t");
    string-replace(|"\r", "\\r");
    string-replace(|"\n", "\\n");
    string-replace(|"\"", "\\\"")  
  
  case-sensitive-template-prods:
    TemplateProduction(SortDef(_), _, attrs) -> <id>
    where
      <not(?Attrs(<id>); fetch-elem(?CaseInsensitive()))> attrs
      
  case-sensitive-template-prods:
    TemplateProductionWithCons(SortCons(SortDef(_), Constructor(_)), _, attrs) -> <id>
    where
      <not(?Attrs(<id>); fetch-elem(?CaseInsensitive()))> attrs
      
  case-insensitive-template-prods:
    TemplateProduction(SortDef(_), _, attrs) -> <id>
    where
      <?Attrs(<id>); fetch-elem(?CaseInsensitive())> attrs
      
  case-insensitive-template-prods:
    TemplateProductionWithCons(SortCons(SortDef(_), Constructor(_)), _, attrs) -> <id>
    where
      <?Attrs(<id>); fetch-elem(?CaseInsensitive())> attrs       
  
  lift-constructors-norm = topdown(try(lift-cons-fun))
    
  lift-cons-fun:
    SdfProductionWithCons(SortCons(symbol, Constructor(cons)), Rhs(symbols*), attrs) -> SdfProduction(symbol, Rhs(symbols*), attrs')
    with
      new-cons := Term(Default(Appl(Unquoted("default"), [ Appl(Unquoted("appl"), [ Appl(Unquoted("unquoted"), [Fun(Quoted("\"cons\""))]), List([ List([ Appl(Unquoted("fun"), [Appl(Unquoted("quoted"), [Fun(Quoted(<escape; double-quote> cons))])])])])])]))); 
      attrs'   := <(?Attrs([]) + ?NoAttrs()); !Attrs([new-cons]) <+ ?Attrs(attrs*); !Attrs([new-cons, attrs*])> attrs
        
    
  expand-priorities(|tokenize-chars) = topdown(try(expand-priority(|tokenize-chars)))
    
  expand-priority(|tokenize-chars):
    SimpleRefGroup(ref) -> SimpleGroup(ref')
    with
      ref' := <sortcons-to-prod(|tokenize-chars)> ref
        
    expand-priority(|tokenize-chars):
        ProdsRefGroup(ref) -> ProdsGroup(ref')
         with
            ref' := <map(sortcons-to-prod(|tokenize-chars))> ref
    
    expand-priority(|tokenize-chars):
        AssocRefGroup(a, ref) -> AssocGroup(a, ref')
        with
            ref' := <map(sortcons-to-prod(|tokenize-chars))> ref
        
    sortcons-to-prod(|tokenize-chars):
        SortConsRef(Sort(s), Constructor(c)) -> prod
        with
            prod := <get-def; try(desugar-templates); try(template-to-sdf3-prod(|tokenize-chars)); try(remove-constructor)> c    
        
    basic-norm(|tokenize-chars) :
        Module(Unparameterized(mn), i*, sections*) -> Module(Unparameterized($[normalized/[mn]-normalized]), i*, [new-kernel-section, new-priorities-section, sections'*])
        with
            new-prods*             := <filter(basic-norm-aux(|tokenize-chars)); flatten-list> sections*;
            sections'*             := <filter(not(?SDFSection(ContextFreeSyntax(_)) + ?SDFSection(LexicalSyntax(_)) + ?SDFSection(LexicalPriorities(_)) + ?SDFSection(ContextFreePriorities(_)) + ?SDFSection(Kernel(_)) +?SDFSection(Priorities(_))))> sections*;
            new-priorities*        := <filter(basic-norm-aux-prio(|tokenize-chars)); flatten-list> sections*;
            new-priorities-section := SDFSection(Priorities(new-priorities*));
            new-kernel-section     := SDFSection(Kernel([new-prods*, SdfProduction(Cf(Layout()), Rhs([Cf(Layout()), Cf(Layout())]), Attrs([Assoc(Left())]))]))
    
    basic-norm-aux(|tokenize-chars) :
        SDFSection(Kernel(prods*)) -> prods'*
        with
            prods'* := <map(kernel-basic-norm-prod(|tokenize-chars))> prods*
    
    basic-norm-aux(|tokenize-chars) :
        SDFSection(ContextFreeSyntax(prods*)) -> prods'*
        with
            prods'* := <map(cf-basic-norm-prod(|tokenize-chars))> prods*
    
    kernel-basic-norm-prod(|tokenize-chars):
        SdfProductionWithCons(SortCons(symbol, Constructor(cons)), Rhs(symbols*), attrs) -> SdfProductionWithCons(SortCons(symbol', Constructor(cons)), Rhs(symbols'*), attrs')
        with
            symbol'   := <try(kernel-basic-norm-symb)> symbol;
            symbols'* := <map(try(kernel-basic-norm-symb))> symbols*; 
            attrs'    := <?Attrs([]); !NoAttrs() <+ id> attrs
        
    kernel-basic-norm-prod(|tokenize-chars):
        SdfProduction(symbol, Rhs(symbols*), attrs) -> SdfProduction(symbol', Rhs(symbols'*), attrs')
        with
            symbol'   := <try(kernel-basic-norm-symb)> symbol;
            symbols'* := <map(try(kernel-basic-norm-symb))> symbols*; 
            attrs'    := <?Attrs([]); !NoAttrs() <+ id> attrs
            
     kernel-basic-norm-prod(|tokenize-chars):
      SortConsRef(symbol, cons) -> SortConsRef(symbol', cons)
        with
           symbol'   := <try(kernel-basic-norm-symb)> symbol
    
    kernel-basic-norm-symb:
        s -> <id>
        where
            not(?Lit(_) + ?CharClass(_) + ?CiLit(_))
        where
            s' := <strip-annos; try(?SortDef(x); !Sort(x))> s;
            rules(get-kernel-sorts:+ "kernel-symbols" -> s') 
    
        
    cf-basic-norm-prod(|tokenize-chars):
        SdfProductionWithCons(SortCons(symbol, Constructor(cons)), Rhs(symbols*), attrs) -> SdfProductionWithCons(SortCons(symbol', Constructor(cons)), Rhs(symbols'*), attrs')
        with
            symbol'   := <try(cf-basic-norm-symb)> symbol;
            symbols'* := <map(try(cf-basic-norm-symb)); separate-by(!Cf(Opt(Layout())))> symbols*; 
            attrs'    := <?Attrs([]); !NoAttrs() <+ id> attrs;
            if <not(?[st] <+ ?[])> symbols* then
                rules(get-cf-sorts:+ "cf-symbols" -> Cf(Opt(Layout()))) 
            end
        
    cf-basic-norm-prod(|tokenize-chars):
        SdfProduction(symbol, Rhs(symbols*), attrs) -> SdfProduction(symbol', Rhs(symbols'*), attrs')
        with
            symbol'   := <try(cf-basic-norm-symb)> symbol;
            symbols'* := <map(try(cf-basic-norm-symb)); separate-by(!Cf(Opt(Layout())))> symbols*; 
            attrs'    := <?Attrs([]); !NoAttrs() <+ id> attrs;
            if <not(?[st] <+ ?[])> symbols* then
                rules(get-cf-sorts:+ "cf-symbols" -> Cf(Opt(Layout()))) 
            end
    
    cf-basic-norm-prod(|tokenize-chars):
        SortConsRef(symbol, cons) -> SortConsRef(symbol', cons)
        with
           symbol'   := <try(cf-basic-norm-symb)> symbol
        
    cf-basic-norm-symb:
        s -> Cf(s)
        where
            not(?Lit(_) + ?CharClass(_) + ?CiLit(_))
        where
            s' := <strip-annos; try(?SortDef(x); !Sort(x))> s;
            rules(get-cf-sorts:+ "cf-symbols" -> Cf(s')) 
            
    basic-norm-aux(|tokenize-chars) :
        SDFSection(LexicalSyntax(prods*)) -> [prods'*, lex-injs*]
        with
            prods'*   := <map(lex-basic-norm-prod(|tokenize-chars))> prods*;
            lex-symbs* := <bagof-get-lexical-sorts; make-set> "lexical-symbols" ;
            lex-injs* := <map(create-lex-inj)> lex-symbs*
            
        
    lex-basic-norm-prod(|tokenize-chars):
        SdfProductionWithCons(SortCons(symbol, Constructor(cons)), Rhs(symbols*), attrs) -> SdfProductionWithCons(SortCons(symbol', Constructor(cons)), Rhs(symbols'*), attrs')
        with
            symbol'   := <try(lex-basic-norm-symb)> symbol;
            symbols'* := <map(try(lex-basic-norm-symb))> symbols*; 
            attrs'    := <?Attrs([]); !NoAttrs() <+ id> attrs
        
    lex-basic-norm-prod(|tokenize-chars):
        SdfProduction(symbol, Rhs(symbols*), attrs) -> SdfProduction(symbol', Rhs(symbols'*), attrs')
        with
            symbol'   := <try(lex-basic-norm-symb)> symbol;
            symbols'* := <map(try(lex-basic-norm-symb))> symbols*; 
            attrs'    := <?Attrs([]); !NoAttrs() <+ id> attrs
            
    lex-basic-norm-prod(|tokenize-chars):
       SortConsRef(symbol, cons) -> SortConsRef(symbol', cons)
       with
        symbol'   := <try(lex-basic-norm-symb)> symbol                  
        
    lex-basic-norm-symb:
        s -> Lex(s)
        where
            not(?Lit(_) + ?CharClass(_) + ?CiLit(_))
        where
            s' := <strip-annos; try(?SortDef(x); !Sort(x))> s;
            rules(get-lexical-sorts:+ "lexical-symbols" -> Lex(s')) 
            
    create-lex-inj:
        Lex(s) -> SdfProduction(Cf(s), Rhs([Lex(s')]), NoAttrs())
        where
            s' := <?SortDef(x); !Sort(x) <+ id> s
            
    basic-norm-aux-prio(|tokenize-chars):
        SDFSection(ContextFreePriorities(prio*)) -> prio'*
        with
            prio'* := <map(cf-basic-norm-prio(|tokenize-chars))> prio*
        
    basic-norm-aux-prio(|tokenize-chars):        
        SDFSection(LexicalPriorities(prio*)) -> prio'*
        with
            prio'* := <map(lex-basic-norm-prio(|tokenize-chars))> prio*
    
    basic-norm-aux-prio(|tokenize-chars):        
        SDFSection(Priorities(prio*)) -> prio'*
        with
            prio'* := <map(kernel-basic-norm-prio(|tokenize-chars))> prio*            
            
    lex-basic-norm-prio(|tokenize-chars):
        Chain(groups*) -> Chain(groups'*)
        with
            groups'* := <topdown(try(lex-basic-norm-prod(|tokenize-chars)))> groups*
    
    lex-basic-norm-prio(|tokenize-chars):
        Assoc(g1, associativity, g2) ->  Assoc(g1', associativity, g2')
        with
            g1' :=  <topdown(try(lex-basic-norm-prod(|tokenize-chars)))> g1;
            g2' :=  <topdown(try(lex-basic-norm-prod(|tokenize-chars)))> g2     
    
    cf-basic-norm-prio(|tokenize-chars):
        Chain(groups*) -> Chain(groups'*)
        with
            groups'* := <topdown(try(cf-basic-norm-prod(|tokenize-chars)))> groups*
    
    cf-basic-norm-prio(|tokenize-chars):
        Assoc(g1, associativity, g2) ->  Assoc(g1', associativity, g2')
        with
            g1' :=  <topdown(try(cf-basic-norm-prod(|tokenize-chars)))> g1;
            g2' :=  <topdown(try(cf-basic-norm-prod(|tokenize-chars)))> g2 
    
    kernel-basic-norm-prio(|tokenize-chars):
        Chain(groups*) -> Chain(groups'*)
        with
            groups'* := <topdown(try(kernel-basic-norm-prod(|tokenize-chars)))> groups*
    
    kernel-basic-norm-prio(|tokenize-chars):
        Assoc(g1, associativity, g2) ->  Assoc(g1', associativity, g2')
        with
            g1' :=  <topdown(try(kernel-basic-norm-prod(|tokenize-chars)))> g1;
            g2' :=  <topdown(try(kernel-basic-norm-prod(|tokenize-chars)))> g2 
    
                
    top-sorts:
        Module(Unparameterized(mn), i*, [SDFSection(Kernel(prods*)) | sections*]) -> Module(Unparameterized(mn), i*, [SDFSection(Kernel([new-prods*, prods*, SdfProduction(FileStart(), Rhs([Start(), CharClass(Simple(Present(Numeric("\\256"))))]), NoAttrs())])) | sections'*])
        with
            lex-start-symbols*     := <filter(?SDFSection(LexicalStartSymbols(<id>))); flatten-list> sections*;
            cf-start-symbols*      := <filter(?SDFSection(ContextFreeStartSymbols(<id>))); flatten-list> sections*;
            start-symbols*         := <filter(?SDFSection(KernelStartSymbols(<id>))); flatten-list> sections*;  
            lexical-start-prods*   := <map(lex-start-prod)> lex-start-symbols*;
            start-prods*           := <map(kernel-start-prod)> start-symbols*;
            cf-start-prods*        := <map(cf-start-prod)> cf-start-symbols*;
            sections'*             := <filter(not(?SDFSection(LexicalStartSymbols(_)) + ?SDFSection(ContextFreeStartSymbols(_)) + ?SDFSection(KernelStartSymbols(_))))> sections*;
            new-prods*             := [lexical-start-prods*, cf-start-prods*, start-prods*]
            
    kernel-start-prod:
       s -> SdfProduction(Start(), Rhs([s]), NoAttrs())
    
    lex-start-prod:
       s -> SdfProduction(Start(), Rhs([Lex(s)]), NoAttrs())
       
    cf-start-prod:
        s -> SdfProduction(Start(), Rhs([Cf(Opt(Layout())), Cf(s), Cf(Opt(Layout()))]), NoAttrs())
        with
            rules(get-cf-sorts:+ "cf-symbols" -> Cf(Opt(Layout()))) 
           
       
    regular-norm:
        Module(Unparameterized(mn), i*, sections*@[SDFSection(Kernel(prods*)) | ss*]) -> Module(Unparameterized(mn), i*, [SDFSection(Kernel([prods*, new-prods*])), ss*])//, SDFSection(Priorities([new-priorities*]))])
        with
            cf-symbols*     := <bagof-get-cf-sorts; make-set> "cf-symbols";
            lex-symbols*    := <bagof-get-lexical-sorts; make-set> "lexical-symbols";
            kernel-symbols* := <bagof-get-kernel-sorts; make-set> "kernel-symbols";
            new-prods*      := <filter(regular-norm-symbol); flatten-list> [Cf(Opt(Layout())), cf-symbols*, lex-symbols*, kernel-symbols*]
//            ;new-priorities* := <filter(regular-norm-symbol-prio); flatten-list>  [cf-symbols*, lex-symbols*, kernel-symbols*]
                  
    regular-norm-symbol:
      Label(_, s) -> <regular-norm-symbol> s
      
    regular-norm-symbol:
      Cf(Label(_, s)) -> <strip-annos; regular-norm-symbol> Cf(s)
      
    regular-norm-symbol:
      Lex(Label(_, s)) -> <strip-annos; regular-norm-symbol> Lex(s)             
                  
    regular-norm-symbol:
        s@Lex(Sequence(h, tail*)) -> [SdfProduction(s, Rhs(lex-s*), NoAttrs()), lex-injs*, regular-prods-lex-s*]
        with
          lex-s-injs*             := <map(lex-norm-symb <+ !(<id>, []))> [h | tail*];
          lex-s*                  := <map(?(<id>, _))> lex-s-injs*;
          lex-injs*               := <map(?(_,<id>))> lex-s-injs*;
          regular-prods-lex-s*    := <filter(regular-norm-symbol)> lex-s*
        
    //sequences can only be used in lexical syntax 
    
    regular-norm-symbol:
        Lex(a@Alt(a1, a2)) -> new-prods*
        with
          new-prods*  := <alt-norm-lex; flatten-list> (a, a)
     
    alt-norm-lex:
        (a, b) -> [new-prod, lex-a-inj, lex-b-inj, regular-prods-a*] 
        where
            <not(?Alt(_, _))> a
        with
            (lex-a, lex-a-inj) := <lex-norm-symb <+ !(<id>, [])> a;
            (lex-b, lex-b-inj) := <lex-norm-symb <+ !(<id>, [])> b;
            new-prod           := SdfProduction(lex-b, Rhs([lex-a]), NoAttrs());
            regular-prods-a*   := <regular-norm-symbol <+ ![]> lex-a
    
    alt-norm-lex:
        (a, b) -> [new-prods-a1, new-prods-a2] 
        where
            <(?Alt(a1, a2))> a
        with
            new-prods-a1  := <alt-norm-lex> (a1, b);
            new-prods-a2  := <alt-norm-lex> (a2, b)           
    
    //alternatives can only be used in lexical syntax    
            
    regular-norm-symbol:
        o@Lex(Opt(s)) -> [SdfProduction(o, Rhs([lex-s]), NoAttrs()), SdfProduction(o, Rhs([]), NoAttrs()), lex-s-inj, regular-prods-s*]
        with
            (lex-s, lex-s-inj) := <lex-norm-symb <+ !(<id>, [])> s;
            regular-prods-s*   := <regular-norm-symbol <+ ![]> lex-s
            
    regular-norm-symbol:
        o@Cf(Opt(s)) -> [SdfProduction(o, Rhs([cf-s]), NoAttrs()), SdfProduction(o, Rhs([]), NoAttrs()), regular-prods-s*]    
        with
            cf-s            := <try(cf-norm-symb)> s;
            regular-prods-s* := <regular-norm-symbol <+ ![]> cf-s
            
    regular-norm-symbol:
        o@Opt(s) -> [SdfProduction(o, Rhs([s]), NoAttrs()), SdfProduction(o, Rhs([]), NoAttrs()), regular-prods-s*]    
        with
            regular-prods-s* := <regular-norm-symbol <+ ![]> s        

// EXPERIMENTAL STYLE OF NORMALIZING LISTS
                       
    regular-norm-symbol:
        symb@Lex(Iter(s)) -> [SdfProduction(symb, Rhs([lex-s]), NoAttrs()),
                          SdfProduction(symb, Rhs([symb, lex-s]), NoAttrs()),
                          SdfProduction(lex-iter-star, Rhs([]), NoAttrs()),
                          SdfProduction(lex-iter-star, Rhs([symb]), NoAttrs()), new-inj-prod-iter, new-inj-prod-s,  new-regular-prods-lex-s*]
        with
            (lex-iter-star, new-inj-prod-iter) := <lex-norm-symb <+ !(<id>, [])> IterStar(s);
            (lex-s, new-inj-prod-s)            := <lex-norm-symb <+ !(<id>, [])> s;
            new-regular-prods-lex-s*           := <regular-norm-symbol <+ ![]> lex-s


    regular-norm-symbol:
        symb@Lex(IterStar(s)) -> [SdfProduction(lex-iter, Rhs([lex-s]), NoAttrs()),
                            SdfProduction(lex-iter, Rhs([lex-iter, lex-s]), NoAttrs()),
                            SdfProduction(symb, Rhs([]), NoAttrs()),
                            SdfProduction(symb, Rhs([lex-iter]), NoAttrs()), new-inj-prod-iter, new-inj-prod-s,  new-regular-prods-lex-s*]
        with
            (lex-iter, new-inj-prod-iter)      := <lex-norm-symb <+ !(<id>, [])> Iter(s);
            (lex-s, new-inj-prod-s)            := <lex-norm-symb <+ !(<id>, [])> s;
            new-regular-prods-lex-s*           := <regular-norm-symbol <+ ![]> lex-s      
            
     regular-norm-symbol:
        symb@Cf(Iter(s)) -> [SdfProduction(symb, Rhs([cf-s]), NoAttrs()),
                         SdfProduction(symb, Rhs(<separate-by(!Cf(Opt(Layout())))> [symb, cf-s]), NoAttrs()),
                         SdfProduction(cf-iter-star, Rhs([]), NoAttrs()),
                         SdfProduction(cf-iter-star, Rhs([symb]), NoAttrs()),  new-regular-prods-cf-s*]
        with
            cf-iter-star            := <try(cf-norm-symb)> IterStar(s);
            cf-s                    := <try(cf-norm-symb)> s;
            new-regular-prods-cf-s* := <regular-norm-symbol <+ ![]> cf-s
     
     regular-norm-symbol:
        symb@Cf(IterStar(s)) -> [SdfProduction(cf-iter, Rhs([cf-s]), NoAttrs()),
                           SdfProduction(cf-iter, Rhs(<separate-by(!Cf(Opt(Layout())))>[cf-iter, cf-s]), NoAttrs()),
                           SdfProduction(symb, Rhs([]), NoAttrs()),
                           SdfProduction(symb, Rhs([cf-iter]), NoAttrs()), new-regular-prods-cf-s*]
        with
            cf-iter                 := <try(cf-norm-symb)> Iter(s);
            cf-s                    := <try(cf-norm-symb)> s;
            new-regular-prods-cf-s* := <regular-norm-symbol <+ ![]> cf-s         
            
     regular-norm-symbol:
        symb@Iter(s) -> [SdfProduction(symb, Rhs([s]), NoAttrs()),
                              SdfProduction(symb, Rhs([symb, s]), NoAttrs()),
                              SdfProduction(iter-star, Rhs([]), NoAttrs()),
                              SdfProduction(iter-star, Rhs([symb]), NoAttrs()), new-regular-prods-s*]
        with
            iter-star             := IterStar(s);
            new-regular-prods-s*  := <regular-norm-symbol <+ ![]> s
         
    regular-norm-symbol:
        symb@IterStar(s) -> [SdfProduction(lex-iter, Rhs([s]), NoAttrs()),
                                  SdfProduction(lex-iter, Rhs([lex-iter, s]), NoAttrs()),
                                  SdfProduction(symb, Rhs([]), NoAttrs()),
                                  SdfProduction(symb, Rhs([lex-iter]), NoAttrs()), new-regular-prods-s*]
        with
            lex-iter                :=  Iter(s);
            new-regular-prods-s*    := <regular-norm-symbol <+ ![]> s     
            
    regular-norm-symbol:
        symb@Lex(IterSep(s, sep)) -> [SdfProduction(symb, Rhs([lex-s]), NoAttrs()),
                                      SdfProduction(symb, Rhs([symb, lex-sep, lex-s]), NoAttrs()),
                                      SdfProduction(lex-iter-star-sep, Rhs([]), NoAttrs()),
                                      SdfProduction(lex-iter-star-sep, Rhs([symb]), NoAttrs()), 
                                      new-inj-prod-iter, new-inj-prod-s, new-inj-prod-sep, new-regular-prods-lex-s*]
        with
            (lex-iter-star-sep, new-inj-prod-iter)     := <lex-norm-symb <+ !(<id>, [])> IterStarSep(s, sep);
            (lex-s, new-inj-prod-s)                    := <lex-norm-symb <+ !(<id>, [])> s;
            (lex-sep, new-inj-prod-sep)                := <lex-norm-symb <+ !(<id>, [])> sep;
            new-regular-prods-lex-s*                   := <regular-norm-symbol <+ ![]> lex-s
            
     regular-norm-symbol:
        symb@Lex(IterStarSep(s, sep)) -> [SdfProduction(lex-iter-sep, Rhs([lex-s]), NoAttrs()),
                                        SdfProduction(lex-iter-sep, Rhs([lex-iter-sep, lex-sep, lex-s]), NoAttrs()),
                                        SdfProduction(symb, Rhs([]), NoAttrs()),
                                        SdfProduction(symb, Rhs([lex-iter-sep]), NoAttrs()),
                                        new-inj-prod-iter, new-inj-prod-s, new-inj-prod-sep, new-regular-prods-lex-s*]
        with
            (lex-iter-sep, new-inj-prod-iter)  := <lex-norm-symb <+ !(<id>, [])> IterSep(s, sep);
            (lex-s, new-inj-prod-s)            := <lex-norm-symb <+ !(<id>, [])> s;
            (lex-sep, new-inj-prod-sep)        := <lex-norm-symb <+ !(<id>, [])> sep;
            new-regular-prods-lex-s*           := <regular-norm-symbol <+ ![]> lex-s       
            
      regular-norm-symbol:
        symb@Cf(IterSep(s, sep)) -> [ SdfProduction(symb, Rhs([cf-s]), NoAttrs()),
                                      SdfProduction(symb, Rhs(<separate-by(!Cf(Opt(Layout())))>[symb, cf-sep, cf-s]), NoAttrs()),
                                      SdfProduction(cf-iter-star-sep, Rhs([]), NoAttrs()),
                                      SdfProduction(cf-iter-star-sep, Rhs([symb]), NoAttrs()) 
                                      , new-regular-prods-cf-s*]
        with
            cf-iter-star-sep        := <try(cf-norm-symb)> IterStarSep(s, sep);
            cf-s                    := <try(cf-norm-symb)> s;
            cf-sep                  := <try(cf-norm-symb)> sep;
            new-regular-prods-cf-s* := <regular-norm-symbol <+ ![]> cf-s
     
     regular-norm-symbol:
        symb@Cf(IterStarSep(s, sep)) -> [ SdfProduction(cf-iter-sep, Rhs([cf-s]), NoAttrs()),
                                          SdfProduction(cf-iter-sep, Rhs(<separate-by(!Cf(Opt(Layout())))>[cf-iter-sep, cf-sep, cf-s]), NoAttrs()),
                                          SdfProduction(symb, Rhs([]), NoAttrs()),
                                          SdfProduction(symb, Rhs([cf-iter-sep]), NoAttrs()),
                                          new-regular-prods-cf-s*]
        with
            cf-iter-sep             := <try(cf-norm-symb)> IterSep(s, sep);
            cf-s                    := <try(cf-norm-symb)> s;
            cf-sep                  := <try(cf-norm-symb)> sep;
            new-regular-prods-cf-s* := <regular-norm-symbol <+ ![]> cf-s
            
     regular-norm-symbol:
        symb@IterSep(s, sep) -> [SdfProduction(symb, Rhs([s]), NoAttrs()),
                                      SdfProduction(symb, Rhs([symb, sep, s]), NoAttrs()),
                                      SdfProduction(iter-star-sep, Rhs([]), NoAttrs()),
                                      SdfProduction(iter-star-sep, Rhs([symb]), NoAttrs()), 
                                      new-regular-prods-s*]
        with
            iter-star-sep          :=  IterStarSep(s, sep);
            new-regular-prods-s*   := <regular-norm-symbol <+ ![]> s
            
     regular-norm-symbol:
        symb@IterStarSep(s, sep) -> [SdfProduction(iter-sep, Rhs([s]), NoAttrs()),
                                          SdfProduction(iter-sep, Rhs([iter-sep, sep, s]), NoAttrs()),
                                          SdfProduction(symb, Rhs([]), NoAttrs()),
                                          SdfProduction(symb, Rhs([iter-sep]), NoAttrs()),
                                          new-regular-prods-s*]
        with
            iter-sep               := IterSep(s, sep);
            new-regular-prods-s*   := <regular-norm-symbol <+ ![]> s                    
                    

//  OLD STYLE OF NORMALIZATION FOR LISTS
                
//    regular-norm-symbol:
//        symb@Lex(Iter(s)) -> [SdfProduction(symb, Rhs([lex-s]), NoAttrs()),
//                          SdfProduction(symb, Rhs([symb, symb]), Attrs([Assoc(Left())])),
//                          SdfProduction(symb, Rhs([symb, lex-iter-star]), NoAttrs()),
//                          SdfProduction(symb, Rhs([lex-iter-star, symb]), NoAttrs()),
//                          SdfProduction(lex-iter-star, Rhs([lex-iter-star, lex-iter-star]), Attrs([Assoc(Left())])),
//                          SdfProduction(lex-iter-star, Rhs([]), NoAttrs()),
//                          SdfProduction(lex-iter-star, Rhs([symb]), NoAttrs()), new-inj-prod-iter, new-inj-prod-s,  new-regular-prods-lex-s*]
//        with
//            (lex-iter-star, new-inj-prod-iter) := <lex-norm-symb <+ !(<id>, [])> IterStar(s);
//            (lex-s, new-inj-prod-s)            := <lex-norm-symb <+ !(<id>, [])> s;
//            new-regular-prods-lex-s*           := <regular-norm-symbol <+ ![]> lex-s
//            
//    regular-norm-symbol:
//        symb@Lex(IterStar(s)) -> [SdfProduction(lex-iter, Rhs([lex-s]), NoAttrs()),
//                            SdfProduction(lex-iter, Rhs([lex-iter, lex-iter]), Attrs([Assoc(Left())])),
//                            SdfProduction(lex-iter, Rhs([lex-iter, symb]), NoAttrs()),
//                            SdfProduction(lex-iter, Rhs([symb, lex-iter]), NoAttrs()),
//                            SdfProduction(symb, Rhs([symb, symb]), Attrs([Assoc(Left())])),
//                            SdfProduction(symb, Rhs([]), NoAttrs()),
//                            SdfProduction(symb, Rhs([lex-iter]), NoAttrs()), new-inj-prod-iter, new-inj-prod-s,  new-regular-prods-lex-s*]
//        with
//            (lex-iter, new-inj-prod-iter)      := <lex-norm-symb <+ !(<id>, [])> Iter(s);
//            (lex-s, new-inj-prod-s)            := <lex-norm-symb <+ !(<id>, [])> s;
//            new-regular-prods-lex-s*           := <regular-norm-symbol <+ ![]> lex-s        
//     
//     
//     regular-norm-symbol:
//        symb@Cf(Iter(s)) -> [SdfProduction(symb, Rhs([cf-s]), NoAttrs()),
//                         SdfProduction(symb, Rhs(<separate-by(!Cf(Opt(Layout())))> [symb, symb]), Attrs([Assoc(Left())])),
//                         SdfProduction(symb, Rhs(<separate-by(!Cf(Opt(Layout())))> [symb, cf-iter-star]), NoAttrs()),
//                         SdfProduction(symb, Rhs(<separate-by(!Cf(Opt(Layout())))> [cf-iter-star, symb]), NoAttrs()),
//                         SdfProduction(cf-iter-star, Rhs(<separate-by(!Cf(Opt(Layout())))> [cf-iter-star, cf-iter-star]), Attrs([Assoc(Left())])),
//                         SdfProduction(cf-iter-star, Rhs([]), NoAttrs()),
//                         SdfProduction(cf-iter-star, Rhs([symb]), NoAttrs()),  new-regular-prods-cf-s*]
//        with
//            cf-iter-star            := <try(cf-norm-symb)> IterStar(s);
//            cf-s                    := <try(cf-norm-symb)> s;
//            new-regular-prods-cf-s* := <regular-norm-symbol <+ ![]> cf-s
//     
//     regular-norm-symbol:
//        symb@Cf(IterStar(s)) -> [SdfProduction(cf-iter, Rhs([cf-s]), NoAttrs()),
//                           SdfProduction(cf-iter, Rhs(<separate-by(!Cf(Opt(Layout())))>[cf-iter, cf-iter]), Attrs([Assoc(Left())])),
//                           SdfProduction(cf-iter, Rhs(<separate-by(!Cf(Opt(Layout())))>[cf-iter, symb]), NoAttrs()),
//                           SdfProduction(cf-iter, Rhs(<separate-by(!Cf(Opt(Layout())))>[symb, cf-iter]), NoAttrs()),
//                           SdfProduction(symb, Rhs(<separate-by(!Cf(Opt(Layout())))>[symb, symb]), Attrs([Assoc(Left())])),
//                           SdfProduction(symb, Rhs([]), NoAttrs()),
//                           SdfProduction(symb, Rhs([cf-iter]), NoAttrs()), new-regular-prods-cf-s*]
//        with
//            cf-iter                 := <try(cf-norm-symb)> Iter(s);
//            cf-s                    := <try(cf-norm-symb)> s;
//            new-regular-prods-cf-s* := <regular-norm-symbol <+ ![]> cf-s
//     
//     regular-norm-symbol:
//        symb@Iter(s) -> [SdfProduction(symb, Rhs([s]), NoAttrs()),
//                              SdfProduction(symb, Rhs([symb, symb]), Attrs([Assoc(Left())])),
//                              SdfProduction(symb, Rhs([symb, iter-star]), NoAttrs()),
//                              SdfProduction(symb, Rhs([iter-star, symb]), NoAttrs()),
//                              SdfProduction(iter-star, Rhs([iter-star, iter-star]), Attrs([Assoc(Left())])),
//                              SdfProduction(iter-star, Rhs([]), NoAttrs()),
//                              SdfProduction(iter-star, Rhs([symb]), NoAttrs()), new-regular-prods-s*]
//        with
//            iter-star             := IterStar(s);
//            new-regular-prods-s*  := <regular-norm-symbol <+ ![]> s
//            
//    regular-norm-symbol:
//        symb@IterStar(s) -> [SdfProduction(lex-iter, Rhs([s]), NoAttrs()),
//                                  SdfProduction(lex-iter, Rhs([lex-iter, lex-iter]), Attrs([Assoc(Left())])),
//                                  SdfProduction(lex-iter, Rhs([lex-iter, symb]), NoAttrs()),
//                                  SdfProduction(lex-iter, Rhs([symb, lex-iter]), NoAttrs()),
//                                  SdfProduction(symb, Rhs([symb, symb]), Attrs([Assoc(Left())])),
//                                  SdfProduction(symb, Rhs([]), NoAttrs()),
//                                  SdfProduction(symb, Rhs([lex-iter]), NoAttrs()), new-regular-prods-s*]
//        with
//            lex-iter                :=  Iter(s);
//            new-regular-prods-s*    := <regular-norm-symbol <+ ![]> s      
//     
//     
//     
//     
//     regular-norm-symbol:
//        symb@Lex(IterSep(s, sep)) -> [SdfProduction(symb, Rhs([lex-s]), NoAttrs()),
//                                      SdfProduction(symb, Rhs([symb, lex-sep, symb]), Attrs([Assoc(Left())])),
//                                      SdfProduction(symb, Rhs([symb, lex-sep, lex-iter-star-sep]), NoAttrs()),
//                                      SdfProduction(symb, Rhs([lex-iter-star-sep, lex-sep, symb]), NoAttrs()),
//                                      SdfProduction(lex-iter-star-sep, Rhs([lex-iter-star-sep, lex-sep, lex-iter-star-sep]), Attrs([Assoc(Left())])),
//                                      SdfProduction(lex-iter-star-sep, Rhs([]), NoAttrs()),
//                                      SdfProduction(lex-iter-star-sep, Rhs([symb]), NoAttrs()), 
//                                      new-inj-prod-iter, new-inj-prod-s, new-inj-prod-sep, new-regular-prods-lex-s*]
//        with
//            (lex-iter-star-sep, new-inj-prod-iter)     := <lex-norm-symb <+ !(<id>, [])> IterStarSep(s, sep);
//            (lex-s, new-inj-prod-s)                    := <lex-norm-symb <+ !(<id>, [])> s;
//            (lex-sep, new-inj-prod-sep)                := <lex-norm-symb <+ !(<id>, [])> sep;
//            new-regular-prods-lex-s*                   := <regular-norm-symbol <+ ![]> lex-s
//            
//     regular-norm-symbol:
//        symb@Lex(IterStarSep(s, sep)) -> [SdfProduction(lex-iter-sep, Rhs([lex-s]), NoAttrs()),
//                                        SdfProduction(lex-iter-sep, Rhs([lex-iter-sep, lex-sep, lex-iter-sep]), Attrs([Assoc(Left())])),
//                                        SdfProduction(lex-iter-sep, Rhs([lex-iter-sep, lex-sep, symb]), NoAttrs()),
//                                        SdfProduction(lex-iter-sep, Rhs([symb, lex-sep, lex-iter-sep]), NoAttrs()),
//                                        SdfProduction(symb, Rhs([symb, lex-sep, symb]), Attrs([Assoc(Left())])),
//                                        SdfProduction(symb, Rhs([]), NoAttrs()),
//                                        SdfProduction(symb, Rhs([lex-iter-sep]), NoAttrs()),
//                                        new-inj-prod-iter, new-inj-prod-s, new-inj-prod-sep, new-regular-prods-lex-s*]
//        with
//            (lex-iter-sep, new-inj-prod-iter)  := <lex-norm-symb <+ !(<id>, [])> IterSep(s, sep);
//            (lex-s, new-inj-prod-s)            := <lex-norm-symb <+ !(<id>, [])> s;
//            (lex-sep, new-inj-prod-sep)        := <lex-norm-symb <+ !(<id>, [])> sep;
//            new-regular-prods-lex-s*           := <regular-norm-symbol <+ ![]> lex-s
//         
//     
//      regular-norm-symbol:
//        symb@Cf(IterSep(s, sep)) -> [ SdfProduction(symb, Rhs([cf-s]), NoAttrs()),
//                                      SdfProduction(symb, Rhs(<separate-by(!Cf(Opt(Layout())))>[symb, cf-sep, symb]), Attrs([Assoc(Left())])),
//                                      SdfProduction(symb, Rhs(<separate-by(!Cf(Opt(Layout())))>[symb, cf-sep, cf-iter-star-sep]), NoAttrs()),
//                                      SdfProduction(symb, Rhs(<separate-by(!Cf(Opt(Layout())))>[cf-iter-star-sep, cf-sep, symb]), NoAttrs()),
//                                      SdfProduction(cf-iter-star-sep, Rhs(<separate-by(!Cf(Opt(Layout())))>[cf-iter-star-sep, cf-sep, cf-iter-star-sep]), Attrs([Assoc(Left())])),
//                                      SdfProduction(cf-iter-star-sep, Rhs([]), NoAttrs()),
//                                      SdfProduction(cf-iter-star-sep, Rhs([symb]), NoAttrs()) 
//                                      , new-regular-prods-cf-s*]
//        with
//            cf-iter-star-sep        := <try(cf-norm-symb)> IterStarSep(s, sep);
//            cf-s                    := <try(cf-norm-symb)> s;
//            cf-sep                  := <try(cf-norm-symb)> sep;
//            new-regular-prods-cf-s* := <regular-norm-symbol <+ ![]> cf-s
//     
//     regular-norm-symbol:
//        symb@Cf(IterStarSep(s, sep)) -> [ SdfProduction(cf-iter-sep, Rhs([cf-s]), NoAttrs()),
//                                          SdfProduction(cf-iter-sep, Rhs(<separate-by(!Cf(Opt(Layout())))>[cf-iter-sep, cf-sep, cf-iter-sep]), Attrs([Assoc(Left())])),
//                                          SdfProduction(cf-iter-sep, Rhs(<separate-by(!Cf(Opt(Layout())))>[cf-iter-sep, cf-sep, symb]), NoAttrs()),
//                                          SdfProduction(cf-iter-sep, Rhs(<separate-by(!Cf(Opt(Layout())))>[symb, cf-sep, cf-iter-sep]), NoAttrs()),
//                                          SdfProduction(symb, Rhs(<separate-by(!Cf(Opt(Layout())))>[symb, cf-sep, symb]), Attrs([Assoc(Left())])),
//                                          SdfProduction(symb, Rhs([]), NoAttrs()),
//                                          SdfProduction(symb, Rhs([cf-iter-sep]), NoAttrs()),
//                                          new-regular-prods-cf-s*]
//        with
//            cf-iter-sep             := <try(cf-norm-symb)> IterSep(s, sep);
//            cf-s                    := <try(cf-norm-symb)> s;
//            cf-sep                  := <try(cf-norm-symb)> sep;
//            new-regular-prods-cf-s* := <regular-norm-symbol <+ ![]> cf-s
//            
//     regular-norm-symbol:
//        symb@IterSep(s, sep) -> [SdfProduction(symb, Rhs([s]), NoAttrs()),
//                                      SdfProduction(symb, Rhs([symb, sep, symb]), Attrs([Assoc(Left())])),
//                                      SdfProduction(symb, Rhs([symb, sep, iter-star-sep]), NoAttrs()),
//                                      SdfProduction(symb, Rhs([iter-star-sep, sep, symb]), NoAttrs()),
//                                      SdfProduction(iter-star-sep, Rhs([iter-star-sep, sep, iter-star-sep]), Attrs([Assoc(Left())])),
//                                      SdfProduction(iter-star-sep, Rhs([]), NoAttrs()),
//                                      SdfProduction(iter-star-sep, Rhs([symb]), NoAttrs()), 
//                                      new-regular-prods-s*]
//        with
//            iter-star-sep          :=  IterStarSep(s, sep);
//            new-regular-prods-s*   := <regular-norm-symbol <+ ![]> s
//            
//     regular-norm-symbol:
//        symb@IterStarSep(s, sep) -> [SdfProduction(iter-sep, Rhs([s]), NoAttrs()),
//                                          SdfProduction(iter-sep, Rhs([iter-sep, sep, iter-sep]), Attrs([Assoc(Left())])),
//                                          SdfProduction(iter-sep, Rhs([iter-sep, sep, symb]), NoAttrs()),
//                                          SdfProduction(iter-sep, Rhs([symb, sep, iter-sep]), NoAttrs()),
//                                          SdfProduction(symb, Rhs([symb, sep, symb]), Attrs([Assoc(Left())])),
//                                          SdfProduction(symb, Rhs([]), NoAttrs()),
//                                          SdfProduction(symb, Rhs([iter-sep]), NoAttrs()),
//                                          new-regular-prods-s*]
//        with
//            iter-sep               := IterSep(s, sep);
//            new-regular-prods-s*   := <regular-norm-symbol <+ ![]> s       
//            
//            
//     regular-norm-symbol-prio:
//        symb@Lex(Iter(s)) -> [ Chain([ ProdsGroup([p1, p2, p3, p4]), ProdsGroup([ p5, p6])])
//                             , Chain([ WithArguments(SimpleGroup(p2), Default(["1"])), SimpleGroup(p4)])
//                             , Chain([ WithArguments(SimpleGroup(p3), Default(["1"])), SimpleGroup(p2)])
//                             , Chain([ WithArguments(SimpleGroup(p3), Default(["1"])), SimpleGroup(p1)])
//                             , Chain([ WithArguments(SimpleGroup(p1), Default(["1"])), SimpleGroup(p2)])
//                             , Chain([ WithArguments(SimpleGroup(p1), Default(["1"])), SimpleGroup(p3)])]
//         with
//            lex-iter-star := Lex(IterStar(s)); //don't need to call lex-norm-symb because it was already done by regular-norm-symb
//            p1            := SdfProduction(symb, Rhs([symb, symb]), Attrs([Assoc(Left())]));
//            p2            := SdfProduction(symb, Rhs([symb, lex-iter-star]), NoAttrs());
//            p3            := SdfProduction(symb, Rhs([lex-iter-star, symb]), NoAttrs());
//            p4            := SdfProduction(lex-iter-star, Rhs([lex-iter-star, lex-iter-star]), Attrs([Assoc(Left())]));
//            p5            := SdfProduction(lex-iter-star, Rhs([]), NoAttrs());
//            p6            := SdfProduction(lex-iter-star, Rhs([symb]), NoAttrs())    
//            
//     regular-norm-symbol-prio:
//        symb@Lex(IterStar(s)) -> [ Chain([ ProdsGroup([p1, p2, p3, p4]), ProdsGroup([ p5, p6])])
//                                 , Chain([ WithArguments(SimpleGroup(p2), Default(["1"])), SimpleGroup(p4)])
//                                 , Chain([ WithArguments(SimpleGroup(p3), Default(["1"])), SimpleGroup(p2)])
//                                 , Chain([ WithArguments(SimpleGroup(p3), Default(["1"])), SimpleGroup(p1)])
//                                 , Chain([ WithArguments(SimpleGroup(p1), Default(["1"])), SimpleGroup(p2)])
//                                 , Chain([ WithArguments(SimpleGroup(p1), Default(["1"])), SimpleGroup(p3)])]
//         with
//            lex-iter := Lex(Iter(s)) ;
//            p1       := SdfProduction(lex-iter, Rhs([lex-iter, lex-iter]), Attrs([Assoc(Left())]));
//            p2       := SdfProduction(lex-iter, Rhs([lex-iter, symb]), NoAttrs()) ;
//            p3       := SdfProduction(lex-iter, Rhs([symb, lex-iter]), NoAttrs()) ;
//            p4       := SdfProduction(symb, Rhs([symb, symb]), Attrs([Assoc(Left())])) ;
//            p5       := SdfProduction(symb, Rhs([]), NoAttrs()) ;
//            p6       := SdfProduction(symb, Rhs([lex-iter]), NoAttrs())
//            
//     regular-norm-symbol-prio:
//        symb@Cf(IterStar(s)) -> [Chain([ProdsGroup([ p1, p2, p3, p4]), ProdsGroup([p5, p6])])
//                               , Chain([ WithArguments(SimpleGroup(p2), Default(["2"])), SimpleGroup(p4)])
//                               , Chain([ WithArguments(SimpleGroup(p3), Default(["2"])), SimpleGroup(p2)])
//                               , Chain([ WithArguments(SimpleGroup(p3), Default(["2"])), SimpleGroup(p1)])
//                               , Chain([ WithArguments(SimpleGroup(p1), Default(["2"])), SimpleGroup(p2)])
//                               , Chain([ WithArguments(SimpleGroup(p1), Default(["2"])), SimpleGroup(p3)])]
//         with
//            cf-iter := Cf(Iter(s));
//            p1      := SdfProduction(cf-iter, Rhs(<separate-by(!Cf(Opt(Layout())))>[cf-iter, cf-iter]), Attrs([Assoc(Left())]));
//            p2      := SdfProduction(cf-iter, Rhs(<separate-by(!Cf(Opt(Layout())))>[cf-iter, symb]), NoAttrs()) ;
//            p3      := SdfProduction(cf-iter, Rhs(<separate-by(!Cf(Opt(Layout())))>[symb, cf-iter]), NoAttrs()) ;
//            p4      := SdfProduction(symb, Rhs(<separate-by(!Cf(Opt(Layout())))>[symb, symb]), Attrs([Assoc(Left())]))  ;
//            p5      := SdfProduction(symb, Rhs([]), NoAttrs()) ;
//            p6      := SdfProduction(symb, Rhs([cf-iter]), NoAttrs())
//            
//            
//      regular-norm-symbol-prio:
//        symb@Cf(Iter(s)) -> [Chain([ProdsGroup([p1, p2, p3, p4]), ProdsGroup([p5, p6])])
//                           , Chain([ WithArguments(SimpleGroup(p2), Default(["2"])), SimpleGroup(p4)])
//                           , Chain([ WithArguments(SimpleGroup(p3), Default(["2"])), SimpleGroup(p2)])
//                           , Chain([ WithArguments(SimpleGroup(p3), Default(["2"])), SimpleGroup(p1)])
//                           , Chain([ WithArguments(SimpleGroup(p1), Default(["2"])), SimpleGroup(p2)])
//                           , Chain([ WithArguments(SimpleGroup(p1), Default(["2"])), SimpleGroup(p3)])]
//         with
//            cf-iter-star := Cf(IterStar(s));
//            p1           := SdfProduction(symb, Rhs(<separate-by(!Cf(Opt(Layout())))> [symb, symb]), Attrs([Assoc(Left())]));
//            p2           := SdfProduction(symb, Rhs(<separate-by(!Cf(Opt(Layout())))> [symb, cf-iter-star]), NoAttrs()) ;
//            p3           := SdfProduction(symb, Rhs(<separate-by(!Cf(Opt(Layout())))> [cf-iter-star, symb]), NoAttrs()) ;
//            p4           := SdfProduction(cf-iter-star, Rhs(<separate-by(!Cf(Opt(Layout())))> [cf-iter-star, cf-iter-star]), Attrs([Assoc(Left())]))  ;
//            p5           := SdfProduction(cf-iter-star, Rhs([]), NoAttrs()) ;
//            p6           := SdfProduction(cf-iter-star, Rhs([symb]), NoAttrs())   
//            
//            
//     regular-norm-symbol-prio:
//        symb@Iter(s) -> [ Chain([ ProdsGroup([p1, p2, p3, p4]), ProdsGroup([ p5, p6])])
//                             , Chain([ WithArguments(SimpleGroup(p2), Default(["1"])), SimpleGroup(p4)])
//                             , Chain([ WithArguments(SimpleGroup(p3), Default(["1"])), SimpleGroup(p2)])
//                             , Chain([ WithArguments(SimpleGroup(p3), Default(["1"])), SimpleGroup(p1)])
//                             , Chain([ WithArguments(SimpleGroup(p1), Default(["1"])), SimpleGroup(p2)])
//                             , Chain([ WithArguments(SimpleGroup(p1), Default(["1"])), SimpleGroup(p3)])]
//         with
//            iter-star     := IterStar(s); 
//            p1            := SdfProduction(symb, Rhs([symb, symb]), Attrs([Assoc(Left())]));
//            p2            := SdfProduction(symb, Rhs([symb, iter-star]), NoAttrs());
//            p3            := SdfProduction(symb, Rhs([iter-star, symb]), NoAttrs());
//            p4            := SdfProduction(iter-star, Rhs([iter-star, iter-star]), Attrs([Assoc(Left())]));
//            p5            := SdfProduction(iter-star, Rhs([]), NoAttrs());
//            p6            := SdfProduction(iter-star, Rhs([symb]), NoAttrs())    
//            
//     regular-norm-symbol-prio:
//        symb@IterStar(s) -> [ Chain([ ProdsGroup([p1, p2, p3, p4]), ProdsGroup([ p5, p6])])
//                                 , Chain([ WithArguments(SimpleGroup(p2), Default(["1"])), SimpleGroup(p4)])
//                                 , Chain([ WithArguments(SimpleGroup(p3), Default(["1"])), SimpleGroup(p2)])
//                                 , Chain([ WithArguments(SimpleGroup(p3), Default(["1"])), SimpleGroup(p1)])
//                                 , Chain([ WithArguments(SimpleGroup(p1), Default(["1"])), SimpleGroup(p2)])
//                                 , Chain([ WithArguments(SimpleGroup(p1), Default(["1"])), SimpleGroup(p3)])]
//         with
//            iter     := Iter(s) ;
//            p1       := SdfProduction(iter, Rhs([iter, iter]), Attrs([Assoc(Left())]));
//            p2       := SdfProduction(iter, Rhs([iter, symb]), NoAttrs()) ;
//            p3       := SdfProduction(iter, Rhs([symb, iter]), NoAttrs()) ;
//            p4       := SdfProduction(symb, Rhs([symb, symb]), Attrs([Assoc(Left())])) ;
//            p5       := SdfProduction(symb, Rhs([]), NoAttrs()) ;
//            p6       := SdfProduction(symb, Rhs([iter]), NoAttrs())       
//            
//     regular-norm-symbol-prio:
//        symb@Lex(IterSep(s, sep)) -> [Chain([ProdsGroup([p1, p2, p3, p4]), ProdsGroup([p5, p6])])
//                                    , Chain([ WithArguments(SimpleGroup(p2), Default(["2"])), SimpleGroup(p4)])
//                                    , Chain([ WithArguments(SimpleGroup(p3), Default(["2"])), SimpleGroup(p2)])
//                                    , Chain([ WithArguments(SimpleGroup(p3), Default(["2"])), SimpleGroup(p1)])
//                                    , Chain([ WithArguments(SimpleGroup(p1), Default(["2"])), SimpleGroup(p2)])
//                                    , Chain([ WithArguments(SimpleGroup(p1), Default(["2"])), SimpleGroup(p3)])]
//         with
//            lex-iter-star-sep           := Lex(IterStarSep(s, sep)); //don't need to call lex-norm-symb because it was already done by regular-norm-symb                               
//            (lex-sep, new-inj-prod-sep) := <lex-norm-symb <+ !(<id>, [])> sep; //is the separator always a literal?
//            p1                          := SdfProduction(symb, Rhs([symb, lex-sep, symb]), Attrs([Assoc(Left())]));
//            p2                          := SdfProduction(symb, Rhs([symb, lex-sep, lex-iter-star-sep]), NoAttrs()) ;
//            p3                          := SdfProduction(symb, Rhs([lex-iter-star-sep, lex-sep, symb]), NoAttrs()) ;
//            p4                          := SdfProduction(lex-iter-star-sep, Rhs([lex-iter-star-sep, lex-sep, lex-iter-star-sep]), Attrs([Assoc(Left())]))  ;
//            p5                          := SdfProduction(lex-iter-star-sep, Rhs([]), NoAttrs()) ;
//            p6                          := SdfProduction(lex-iter-star-sep, Rhs([symb]), NoAttrs())
//            
//     regular-norm-symbol-prio:
//        symb@Lex(IterStarSep(s, sep)) -> [Chain([ProdsGroup([p1, p2, p3, p4]), ProdsGroup([p5, p6])])
//                                        , Chain([ WithArguments(SimpleGroup(p2), Default(["2"])), SimpleGroup(p4)])
//                                        , Chain([ WithArguments(SimpleGroup(p3), Default(["2"])), SimpleGroup(p2)])
//                                        , Chain([ WithArguments(SimpleGroup(p3), Default(["2"])), SimpleGroup(p1)])
//                                        , Chain([ WithArguments(SimpleGroup(p1), Default(["2"])), SimpleGroup(p2)])
//                                        , Chain([ WithArguments(SimpleGroup(p1), Default(["2"])), SimpleGroup(p3)])]
//         with
//            lex-iter-sep                := Lex(IterSep(s, sep)); 
//            (lex-sep, new-inj-prod-sep) := <lex-norm-symb <+ !(<id>, [])> sep; //is the separator always a literal? 
//            p1                          := SdfProduction(lex-iter-sep, Rhs([lex-iter-sep, lex-sep, lex-iter-sep]), Attrs([Assoc(Left())]));
//            p2                          := SdfProduction(lex-iter-sep, Rhs([lex-iter-sep, lex-sep, symb]), NoAttrs()) ;
//            p3                          := SdfProduction(lex-iter-sep, Rhs([symb, lex-sep, lex-iter-sep]), NoAttrs()) ;
//            p4                          := SdfProduction(symb, Rhs([symb, lex-sep, symb]), Attrs([Assoc(Left())]))  ;
//            p5                          := SdfProduction(symb, Rhs([]), NoAttrs()) ;
//            p6                          := SdfProduction(symb, Rhs([lex-iter-sep]), NoAttrs())
// 
//     regular-norm-symbol-prio:
//        symb@Cf(IterSep(s, sep)) -> [Chain([ProdsGroup([p1, p2, p3, p4]), ProdsGroup([p5, p6])])
//                                   , Chain([ WithArguments(SimpleGroup(p2), Default(["4"])), SimpleGroup(p4)])
//                                   , Chain([ WithArguments(SimpleGroup(p3), Default(["4"])), SimpleGroup(p2)])
//                                   , Chain([ WithArguments(SimpleGroup(p3), Default(["4"])), SimpleGroup(p1)])
//                                   , Chain([ WithArguments(SimpleGroup(p1), Default(["4"])), SimpleGroup(p2)])
//                                   , Chain([ WithArguments(SimpleGroup(p1), Default(["4"])), SimpleGroup(p3)])]
//         with
//            cf-iter-star-sep   := <try(cf-norm-symb)> IterStarSep(s, sep);
//            cf-sep             := <try(cf-norm-symb)> sep;
//            p1                 := SdfProduction(symb, Rhs(<separate-by(!Cf(Opt(Layout())))>[symb, cf-sep, symb]), Attrs([Assoc(Left())]));
//            p2                 := SdfProduction(symb, Rhs(<separate-by(!Cf(Opt(Layout())))>[symb, cf-sep, cf-iter-star-sep]), NoAttrs()) ;
//            p3                 := SdfProduction(symb, Rhs(<separate-by(!Cf(Opt(Layout())))>[cf-iter-star-sep, cf-sep, symb]), NoAttrs()) ;
//            p4                 := SdfProduction(cf-iter-star-sep, Rhs(<separate-by(!Cf(Opt(Layout())))>[cf-iter-star-sep, cf-sep, cf-iter-star-sep]), Attrs([Assoc(Left())]))  ;
//            p5                 := SdfProduction(cf-iter-star-sep, Rhs([]), NoAttrs()) ;
//            p6                 := SdfProduction(cf-iter-star-sep, Rhs([symb]), NoAttrs())
//            
//     regular-norm-symbol-prio:
//        symb@Cf(IterStarSep(s, sep)) -> [Chain([ProdsGroup([p1, p2, p3, p4]), ProdsGroup([p5, p6])])
//                                       , Chain([ WithArguments(SimpleGroup(p2), Default(["4"])), SimpleGroup(p4)])
//                                       , Chain([ WithArguments(SimpleGroup(p3), Default(["4"])), SimpleGroup(p2)])
//                                       , Chain([ WithArguments(SimpleGroup(p3), Default(["4"])), SimpleGroup(p1)])
//                                       , Chain([ WithArguments(SimpleGroup(p1), Default(["4"])), SimpleGroup(p2)])
//                                       , Chain([ WithArguments(SimpleGroup(p1), Default(["4"])), SimpleGroup(p3)])]
//         with
//            cf-iter-sep := <try(cf-norm-symb)> IterSep(s, sep);
//            cf-sep      := <try(cf-norm-symb)> sep;
//            p1          := SdfProduction(cf-iter-sep, Rhs(<separate-by(!Cf(Opt(Layout())))>[cf-iter-sep, cf-sep, cf-iter-sep]), Attrs([Assoc(Left())]));
//            p2          := SdfProduction(cf-iter-sep, Rhs(<separate-by(!Cf(Opt(Layout())))>[cf-iter-sep, cf-sep, symb]), NoAttrs()) ;
//            p3          := SdfProduction(cf-iter-sep, Rhs(<separate-by(!Cf(Opt(Layout())))>[symb, cf-sep, cf-iter-sep]), NoAttrs()) ;
//            p4          := SdfProduction(symb, Rhs(<separate-by(!Cf(Opt(Layout())))>[symb, cf-sep, symb]), Attrs([Assoc(Left())]))  ;
//            p5          := SdfProduction(symb, Rhs([]), NoAttrs()) ;
//            p6          := SdfProduction(symb, Rhs([cf-iter-sep]), NoAttrs())
//     
//     regular-norm-symbol-prio:
//        symb@IterSep(s, sep) -> [Chain([ProdsGroup([p1, p2, p3, p4]), ProdsGroup([p5, p6])])
//                               , Chain([ WithArguments(SimpleGroup(p2), Default(["2"])), SimpleGroup(p4)])
//                               , Chain([ WithArguments(SimpleGroup(p3), Default(["2"])), SimpleGroup(p2)])
//                               , Chain([ WithArguments(SimpleGroup(p3), Default(["2"])), SimpleGroup(p1)])
//                               , Chain([ WithArguments(SimpleGroup(p1), Default(["2"])), SimpleGroup(p2)])
//                               , Chain([ WithArguments(SimpleGroup(p1), Default(["2"])), SimpleGroup(p3)])]
//         with
//            iter-star-sep   := IterStarSep(s, sep); //don't need to call lex-norm-symb because it was already done by regular-norm-symb                               
//            p1              := SdfProduction(symb, Rhs([symb, sep, symb]), Attrs([Assoc(Left())]));
//            p2              := SdfProduction(symb, Rhs([symb, sep, iter-star-sep]), NoAttrs()) ;
//            p3              := SdfProduction(symb, Rhs([iter-star-sep, sep, symb]), NoAttrs()) ;
//            p4              := SdfProduction(iter-star-sep, Rhs([iter-star-sep, sep, iter-star-sep]), Attrs([Assoc(Left())]))  ;
//            p5              := SdfProduction(iter-star-sep, Rhs([]), NoAttrs()) ;
//            p6              := SdfProduction(iter-star-sep, Rhs([symb]), NoAttrs())
//            
//     regular-norm-symbol-prio:
//        symb@IterStarSep(s, sep) -> [Chain([ProdsGroup([p1, p2, p3, p4]), ProdsGroup([p5, p6])])
//                                   , Chain([ WithArguments(SimpleGroup(p2), Default(["2"])), SimpleGroup(p4)])
//                                   , Chain([ WithArguments(SimpleGroup(p3), Default(["2"])), SimpleGroup(p2)])
//                                   , Chain([ WithArguments(SimpleGroup(p3), Default(["2"])), SimpleGroup(p1)])
//                                   , Chain([ WithArguments(SimpleGroup(p1), Default(["2"])), SimpleGroup(p2)])
//                                   , Chain([ WithArguments(SimpleGroup(p1), Default(["2"])), SimpleGroup(p3)])]
//         with
//            iter-sep    := IterSep(s, sep); 
//            p1          := SdfProduction(iter-sep, Rhs([iter-sep, sep, iter-sep]), Attrs([Assoc(Left())]));
//            p2          := SdfProduction(iter-sep, Rhs([iter-sep, sep, symb]), NoAttrs()) ;
//            p3          := SdfProduction(iter-sep, Rhs([symb, sep, iter-sep]), NoAttrs()) ;
//            p4          := SdfProduction(symb, Rhs([symb, sep, symb]), Attrs([Assoc(Left())]))  ;
//            p5          := SdfProduction(symb, Rhs([]), NoAttrs()) ;
//            p6          := SdfProduction(symb, Rhs([iter-sep]), NoAttrs())
     
     
     lex-norm-symb:
        s -> (Lex(s), new-prod)
        where
            not(?Lit(_) + ?CharClass(_) + ?CiLit(_))
        where  
            s'             := <strip-annos; try(?SortDef(x); !Sort(x))> s;
            lex-sorts*     := <bagof-get-lexical-sorts> "lexical-symbols";
            new-lex-sorts* := <bagof-get-lexical-sorts> "new-lexical-symbols";
            new-prod       := <fetch(?Lex(s)); ![] <+ <create-lex-inj> Lex(s)> [lex-sorts*, new-lex-sorts*];
            rules(get-lexical-sorts:+ "new-lexical-symbols" -> Lex(s')) 
      
     cf-norm-symb:
        s -> Cf(s)
        where
            not(?Lit(_) + ?CharClass(_) + ?CiLit(_))
     
     //QUESTION: do we add the productions from the priority list to the syntax section?
     //or do they need to be defined in the grammar?       
     //QUESTION: the transitive closure takes into consideration all the priorities, maybe it should be applied when combining modules
     priority-norm(|tokenize-chars):
        Module(Unparameterized(mn), i*, sections*) -> Module(Unparameterized(mn), i*, [sections'*, SDFSection(Priorities([new-priorities*]))])
        with
            sections'*             := <filter(not(?SDFSection(Priorities(_)) + ?SDFSection(ContextFreePriorities(_)) + ?SDFSection(LexicalPriorities(_))))> sections*; 
            cf-priorities*         := <filter(?SDFSection(ContextFreePriorities(<id>))); flatten-list> sections*;
            new-cf-priorities*     := <map(try(norm-prio-fun(|tokenize-chars))); flatten-list> cf-priorities*;
            lex-priorities*        := <filter(?SDFSection(LexicalPriorities(<id>))); flatten-list> sections*;
            new-lex-priorities*    := <map(try(norm-prio-fun(|tokenize-chars))); flatten-list> cf-priorities*;
            kernel-priorities*     := <filter(?SDFSection(Priorities(<id>))); flatten-list> sections*;
            new-kernel-priorities* := <map(try(norm-prio-fun(|tokenize-chars))); flatten-list> kernel-priorities*;
            assoc-prio*            := <filter(?SDFSection(Kernel(<id>))); flatten-list; filter(assoc-prio-fun)> sections*;        

            new-priorities*        := [new-cf-priorities*, new-lex-priorities*, new-kernel-priorities*, assoc-prio*]
            
     //left or assoc associativity productions       
     assoc-prio-fun:
        SdfProductionWithCons(SortCons(symbol, Constructor(cons)), rhs@Rhs(symbols*), attrs) -> Assoc(group, Left(), group)
        where
            <?Attrs(<id>); fetch(?Assoc(Left()) + ?Assoc(Assoc()))> attrs
        with
            group := SimpleRefGroup(SortConsRef(symbol, Constructor(cons)))
        
     assoc-prio-fun:
        p@SdfProduction(symbol, Rhs(symbols*), attrs) ->  Assoc(group, Left(), group)
        where
            <?Attrs(<id>); fetch(?Assoc(Left()) + ?Assoc(Assoc()))> attrs
        with
            group := SimpleGroup(SdfProduction(symbol, Rhs(symbols*), NoAttrs()))
    
     //right associativity productions
     assoc-prio-fun:
        SdfProductionWithCons(SortCons(symbol, Constructor(cons)), rhs, attrs) -> Assoc(group, Right(), group)
        where
            <?Attrs(<id>); fetch(?Assoc(Right()))> attrs
        with
            group := SimpleRefGroup(SortConsRef(symbol, Constructor(cons)))
        
     assoc-prio-fun:
        p@SdfProduction(symbol, Rhs(symbols*), attrs) -> Assoc(group, Right(), group)
        where
            <?Attrs(<id>); fetch(?Assoc(Right()))> attrs
        with
            group := SimpleGroup(SdfProduction(symbol, Rhs(symbols*), NoAttrs()))
           
     //non-assoc associativity productions    
     assoc-prio-fun:
        SdfProductionWithCons(SortCons(symbol, Constructor(cons)), Rhs(symbols*), attrs) -> Assoc(group, NonAssoc(), group)
        where
            <?Attrs(<id>); fetch(?Assoc(NonAssoc()))> attrs
        with
            group := SimpleRefGroup(SortConsRef(symbol, Constructor(cons)))
        
     assoc-prio-fun:
        p@SdfProduction(symbol, Rhs(symbols*), attrs) -> Assoc(group, NonAssoc(), group)
        where
            <?Attrs(<id>); fetch(?Assoc(NonAssoc()))> attrs
        with
            group := SimpleGroup(SdfProduction(symbol, Rhs(symbols*), NoAttrs()))
         
     norm-prio-fun(|tokenize-chars) :
        Chain([first-group | pps]) -> [first-binary, <try(norm-prio-fun(|tokenize-chars))> Chain([<try(remove-constructor)> second-group | ppss])]  
        where
            <?[second-group | ppss]> pps;
            <not(?[])> ppss;
            first-binary := <try(norm-prio-fun(|tokenize-chars))> Chain([<try(remove-constructor)> first-group, <try(remove-constructor)> second-group]) 
     
     norm-prio-fun(|tokenize-chars):
        Chain([group]) -> []
        where
          <check-group(?SimpleGroup(_) + ?SimpleRefGroup(_))> group
     
     norm-prio-fun(|tokenize-chars):
        Chain([group]) -> []  
        where
          <check-group(?ProdsGroup(_) + ?ProdsRefGroup(_))> group 
     
     norm-prio-fun(|tokenize-chars):
        Chain([group1, group2]) -> []
        where
           <check-group(?ProdsGroup([]) + ?ProdsRefGroup([]))> group1
             
     norm-prio-fun(|tokenize-chars):
        Chain([group, ProdsGroup([])]) -> []
        where
        <not(check-group(?AssocGroup(_, _) + ?ProdsGroup(_) + ?AssocRefGroup(_, _) + ?ProdsRefGroup(_)))> group 
        
     norm-prio-fun(|tokenize-chars):
        Chain([group]) -> []   
        where
        <check-group(?AssocGroup(_, []) + ?AssocRefGroup(_, []))> group
           
     norm-prio-fun(|tokenize-chars) :
        Chain([ProdsGroup(p*), group]) -> new-chains
        where
            <not(?[])> p*
        where
            new-chains := <map(create-gt-chain(|SimpleGroup(<id; try(remove-constructor)>), group); try(norm-prio-fun(|tokenize-chars)))> p*
    
     norm-prio-fun(|tokenize-chars) :
        Chain([NonTransitive(ProdsGroup(p*)), group]) -> new-chains
        where
            <not(?[])> p*
        where
            new-chains := <map(create-gt-chain(|NonTransitive(SimpleGroup(<id; try(remove-constructor)>)), group); try(norm-prio-fun(|tokenize-chars)))> p*
     
     norm-prio-fun(|tokenize-chars) :
        Chain([WithArguments(ProdsGroup(p*), args), group]) -> new-chains
        where
            <not(?[])> p*
        where
            new-chains := <map(create-gt-chain(|WithArguments(SimpleGroup(<id; try(remove-constructor)>), args), group); try(norm-prio-fun(|tokenize-chars)))> p*
     
     norm-prio-fun(|tokenize-chars) :
        Chain([NonTransitive(WithArguments(ProdsGroup(p*), args)), group]) -> new-chains
        where
            <not(?[])> p*
        where
            new-chains := <map(create-gt-chain(|NonTransitive(WithArguments(SimpleGroup(<id; try(remove-constructor)>), args)), group); try(norm-prio-fun(|tokenize-chars)))> p*
     
     norm-prio-fun(|tokenize-chars) :
        Chain([WithArguments(NonTransitive(ProdsGroup(p*)), args), group]) -> new-chains
        where
            <not(?[])> p*
        where
            new-chains := <map(create-gt-chain(|WithArguments(NonTransitive(SimpleGroup(<id; try(remove-constructor)>)), args), group); try(norm-prio-fun(|tokenize-chars)))> p*
     
     norm-prio-fun(|tokenize-chars) :
        Chain([ProdsRefGroup(p*), group]) -> new-chains
        where
            <not(?[])> p*
        where
            new-chains := <map(create-gt-chain(|SimpleRefGroup(<id; try(remove-constructor)>), group); try(norm-prio-fun(|tokenize-chars)))> p*
    
     norm-prio-fun(|tokenize-chars) :
        Chain([NonTransitive(ProdsRefGroup(p*)), group]) -> new-chains
        where
            <not(?[])> p*
        where
            new-chains := <map(create-gt-chain(|NonTransitive(SimpleRefGroup(<id; try(remove-constructor)>)), group); try(norm-prio-fun(|tokenize-chars)))> p*
     
     norm-prio-fun(|tokenize-chars) :
        Chain([WithArguments(ProdsRefGroup(p*), args), group]) -> new-chains
        where
            <not(?[])> p*
        where
            new-chains := <map(create-gt-chain(|WithArguments(SimpleRefGroup(<id; try(remove-constructor)>), args), group); try(norm-prio-fun(|tokenize-chars)))> p*
     
     norm-prio-fun(|tokenize-chars) :
        Chain([NonTransitive(WithArguments(ProdsRefGroup(p*), args)), group]) -> new-chains
        where
            <not(?[])> p*
        where
            new-chains := <map(create-gt-chain(|NonTransitive(WithArguments(SimpleRefGroup(<id; try(remove-constructor)>), args)), group); try(norm-prio-fun(|tokenize-chars)))> p*
     
     norm-prio-fun(|tokenize-chars) :
        Chain([WithArguments(NonTransitive(ProdsRefGroup(p*)), args), group]) -> new-chains
        where
            <not(?[])> p*
        where
            new-chains := <map(create-gt-chain(|WithArguments(NonTransitive(SimpleRefGroup(<id; try(remove-constructor)>)), args), group); try(norm-prio-fun(|tokenize-chars)))> p*
          
     norm-prio-fun(|tokenize-chars) :
        Chain([group, ProdsGroup(p*)]) -> new-chains
        where
          <not(check-group(?ProdsGroup(_) + ?AssocGroup(_, _) + ?ProdsRefGroup(_) + ?AssocRefGroup(_, _) ))> group;
          <not(?[])> p*
      where
          new-chains := <map(create-gt-chain(|group, SimpleGroup(<id; try(remove-constructor)>)); try(norm-prio-fun(|tokenize-chars)))> p*
    
    norm-prio-fun(|tokenize-chars) :
        Chain([group, NonTransitive(ProdsGroup(p*))]) -> new-chains
        where
          <not(check-group(?ProdsGroup(_) + ?AssocGroup(_, _) + ?ProdsRefGroup(_) + ?AssocRefGroup(_, _) ))> group;
          <not(?[])> p*
      where
          new-chains := <map(create-gt-chain(|group, SimpleGroup(<id; try(remove-constructor)>)); try(norm-prio-fun(|tokenize-chars)))> p*
        
    norm-prio-fun(|tokenize-chars) :
        Chain([group, WithArguments(ProdsGroup(p*), _)]) -> new-chains
        where
          <not(check-group(?ProdsGroup(_) + ?AssocGroup(_, _) + ?ProdsRefGroup(_) + ?AssocRefGroup(_, _) ))> group;
          <not(?[])> p*
      where
          new-chains := <map(create-gt-chain(|group, SimpleGroup(<id; try(remove-constructor)>)); try(norm-prio-fun(|tokenize-chars)))> p*
    
    norm-prio-fun(|tokenize-chars) :
        Chain([group, NonTransitive(WithArguments(ProdsGroup(p*), _))]) -> new-chains
        where
          <not(check-group(?ProdsGroup(_) + ?AssocGroup(_, _) + ?ProdsRefGroup(_) + ?AssocRefGroup(_, _) ))> group;
          <not(?[])> p*
      where
          new-chains := <map(create-gt-chain(|group, SimpleGroup(<id; try(remove-constructor)>)); try(norm-prio-fun(|tokenize-chars)))> p*
        
    norm-prio-fun(|tokenize-chars) :
        Chain([group, WithArguments(NonTransitive(ProdsGroup(p*)), _)]) -> new-chains
        where
          <not(check-group(?ProdsGroup(_) + ?AssocGroup(_, _) + ?ProdsRefGroup(_) + ?AssocRefGroup(_, _) ))> group;
          <not(?[])> p*
      where
          new-chains := <map(create-gt-chain(|group, SimpleGroup(<id; try(remove-constructor)>)); try(norm-prio-fun(|tokenize-chars)))> p*
         
    norm-prio-fun(|tokenize-chars) :
        Chain([group, ProdsRefGroup(p*)]) -> new-chains
        where
          <not(check-group(?ProdsGroup(_) + ?AssocGroup(_, _) + ?ProdsRefGroup(_) + ?AssocRefGroup(_, _) ))> group;
          <not(?[])> p*
      where
          new-chains := <map(create-gt-chain(|group, SimpleRefGroup(<id; try(remove-constructor)>)); try(norm-prio-fun(|tokenize-chars)))> p*
     
     norm-prio-fun(|tokenize-chars) :
        Chain([group, NonTransitive(ProdsRefGroup(p*))]) -> new-chains
        where
          <not(check-group(?ProdsGroup(_) + ?AssocGroup(_, _) + ?ProdsRefGroup(_) + ?AssocRefGroup(_, _) ))> group;
          <not(?[])> p*
      where
          new-chains := <map(create-gt-chain(|group, SimpleRefGroup(<id; try(remove-constructor)>)); try(norm-prio-fun(|tokenize-chars)))> p*
     
     norm-prio-fun(|tokenize-chars) :
        Chain([group, WithArguments(ProdsRefGroup(p*), _)]) -> new-chains
        where
          <not(check-group(?ProdsGroup(_) + ?AssocGroup(_, _) + ?ProdsRefGroup(_) + ?AssocRefGroup(_, _) ))> group;
          <not(?[])> p*
      where
          new-chains := <map(create-gt-chain(|group, SimpleRefGroup(<id; try(remove-constructor)>)); try(norm-prio-fun(|tokenize-chars)))> p*
     
     norm-prio-fun(|tokenize-chars) :
        Chain([group, NonTransitive(WithArguments(ProdsRefGroup(p*), _))]) -> new-chains
        where
          <not(check-group(?ProdsGroup(_) + ?AssocGroup(_, _) + ?ProdsRefGroup(_) + ?AssocRefGroup(_, _) ))> group;
          <not(?[])> p*
      where
          new-chains := <map(create-gt-chain(|group, SimpleRefGroup(<id; try(remove-constructor)>)); try(norm-prio-fun(|tokenize-chars)))> p*
     
     norm-prio-fun(|tokenize-chars) :
        Chain([group, WithArguments(NonTransitive(ProdsRefGroup(p*)), _)]) -> new-chains
        where
          <not(check-group(?ProdsGroup(_) + ?AssocGroup(_, _) + ?ProdsRefGroup(_) + ?AssocRefGroup(_, _) ))> group;
          <not(?[])> p*
      where
          new-chains := <map(create-gt-chain(|group, SimpleRefGroup(<id; try(remove-constructor)>)); try(norm-prio-fun(|tokenize-chars)))> p*
               
     norm-prio-fun(|tokenize-chars):
        Chain([assocGroup@AssocGroup(_, p*), group]) -> new-chains   
        where
          new-chains := [<try(norm-prio-fun(|tokenize-chars))> Chain([assocGroup]), <try(norm-prio-fun(|tokenize-chars))> Chain([ProdsGroup(p*), group])]
     
     norm-prio-fun(|tokenize-chars):
        Chain([assocGroup@NonTransitive(AssocGroup(_, p*)), group]) -> new-chains   
        where
          new-chains := [<try(norm-prio-fun(|tokenize-chars))> Chain([assocGroup]), <try(norm-prio-fun(|tokenize-chars))> Chain([NonTransitive(ProdsGroup(p*)), group])]
     
     norm-prio-fun(|tokenize-chars):
        Chain([assocGroup@WithArguments(AssocGroup(_, p*), args), group]) -> new-chains   
        where
          new-chains := [<try(norm-prio-fun(|tokenize-chars))> Chain([assocGroup]), <try(norm-prio-fun(|tokenize-chars))> Chain([WithArguments(ProdsGroup(p*), args), group])]
 
     norm-prio-fun(|tokenize-chars):
        Chain([assocGroup@NonTransitive(WithArguments(AssocGroup(_, p*), args)), group]) -> new-chains   
        where
          new-chains := [<try(norm-prio-fun(|tokenize-chars))> Chain([assocGroup]), <try(norm-prio-fun(|tokenize-chars))> Chain([NonTransitive(WithArguments(ProdsGroup(p*), args)), group])]
     
     norm-prio-fun(|tokenize-chars):
        Chain([assocGroup@WithArguments(NonTransitive(AssocGroup(_, p*)), args), group]) -> new-chains   
        where
          new-chains := [<try(norm-prio-fun(|tokenize-chars))> Chain([assocGroup]), <try(norm-prio-fun(|tokenize-chars))> Chain([WithArguments(NonTransitive(ProdsGroup(p*)), args), group])]
     
     norm-prio-fun(|tokenize-chars):
        Chain([assocGroup@AssocRefGroup(_, p*), group]) -> new-chains   
        where
          new-chains := [<try(norm-prio-fun(|tokenize-chars))> Chain([assocGroup]), <try(norm-prio-fun(|tokenize-chars))> Chain([ProdsRefGroup(p*), group])]
     
     norm-prio-fun(|tokenize-chars):
        Chain([assocGroup@NonTransitive(AssocRefGroup(_, p*)), group]) -> new-chains   
        where
          new-chains := [<try(norm-prio-fun(|tokenize-chars))> Chain([assocGroup]), <try(norm-prio-fun(|tokenize-chars))> Chain([NonTransitive(ProdsRefGroup(p*)), group])]
     
     norm-prio-fun(|tokenize-chars):
        Chain([assocGroup@WithArguments(AssocRefGroup(_, p*), args), group]) -> new-chains   
        where
          new-chains := [<try(norm-prio-fun(|tokenize-chars))> Chain([assocGroup]), <try(norm-prio-fun(|tokenize-chars))> Chain([WithArguments(ProdsRefGroup(p*), args), group])]
 
     norm-prio-fun(|tokenize-chars):
        Chain([assocGroup@NonTransitive(WithArguments(AssocRefGroup(_, p*), args)), group]) -> new-chains   
        where
          new-chains := [<try(norm-prio-fun(|tokenize-chars))> Chain([assocGroup]), <try(norm-prio-fun(|tokenize-chars))> Chain([NonTransitive(WithArguments(ProdsRefGroup(p*), args)), group])]
     
     norm-prio-fun(|tokenize-chars):
        Chain([assocGroup@WithArguments(NonTransitive(AssocRefGroup(_, p*)), args), group]) -> new-chains   
        where
          new-chains := [<try(norm-prio-fun(|tokenize-chars))> Chain([assocGroup]), <try(norm-prio-fun(|tokenize-chars))> Chain([WithArguments(NonTransitive(ProdsRefGroup(p*)), args), group])]
                   
     norm-prio-fun(|tokenize-chars):
       Chain([group, assocGroup@AssocGroup(_, p*)]) -> new-chains
       where
            <not(check-group(?ProdsGroup(_)) + check-group(?AssocGroup(_, _)))> group
       where          
            new-chains := [<try(norm-prio-fun(|tokenize-chars))> Chain([assocGroup]), <try(norm-prio-fun(|tokenize-chars))> Chain([group, ProdsGroup(p*)])]  
   
   norm-prio-fun(|tokenize-chars):
       Chain([group, assocGroup@AssocRefGroup(_, p*)]) -> new-chains
       where
            <not(?ProdsGroup(_) + ?AssocGroup(_, _) + ?ProdsRefGroup(_) + ?AssocRefGroup(_, _))> group
       where          
            new-chains := [<try(norm-prio-fun(|tokenize-chars))> Chain([assocGroup]), <try(norm-prio-fun(|tokenize-chars))> Chain([group, ProdsRefGroup(p*)])]               
     
   norm-prio-fun(|tokenize-chars):
        Assoc(<check-group(?ProdsGroup([]) + ?ProdsRefGroup([]))>, _, group) -> <try(norm-prio-fun(|tokenize-chars))> Chain([group])
                
   norm-prio-fun(|tokenize-chars):
        Assoc(ProdsGroup(p*), associativity, group) -> new-chains
        where
            <not(?[])> p*
        where
            new-chains := <map(create-assoc(|SimpleGroup(<id; try(remove-constructor)>), group, associativity); try(norm-prio-fun(|tokenize-chars)))> p*   
   
   norm-prio-fun(|tokenize-chars):
        Assoc(ProdsRefGroup(p*), associativity, group) -> new-chains
        where
            <not(?[])> p*
        where
            new-chains := <map(create-assoc(|SimpleRefGroup(<id; try(remove-constructor)>), group, associativity); try(norm-prio-fun(|tokenize-chars)))> p*   
           
   norm-prio-fun(|tokenize-chars):
        Assoc(group, associativity, ProdsGroup([])) -> <try(norm-prio-fun(|tokenize-chars))> Chain([group])
        where
            <not(?ProdsGroup(_) + ?AssocGroup(_, _) + ?ProdsRefGroup(_) + ?AssocRefGroup(_, _))> group
            
   norm-prio-fun(|tokenize-chars):
        Assoc(group, associativity, ProdsRefGroup([])) -> <try(norm-prio-fun(|tokenize-chars))> Chain([group])
        where
            <not(?ProdsGroup(_) + ?AssocGroup(_, _) + ?ProdsRefGroup(_) + ?AssocRefGroup(_, _))> group         
           
     norm-prio-fun(|tokenize-chars):
        Assoc(group, associativity, ProdsGroup(p*)) -> new-chains
        where
            <not(?ProdsGroup(_) + ?AssocGroup(_, _) + ?ProdsRefGroup(_) + ?AssocRefGroup(_, _))> group;
            <not(?[])> p*
        where
            new-chains := <map(create-assoc(|group, SimpleGroup(<id; try(remove-constructor)>), associativity); try(norm-prio-fun(|tokenize-chars)))> p*  
    
    norm-prio-fun(|tokenize-chars):
        Assoc(group, associativity, ProdsRefGroup(p*)) -> new-chains
        where
            <not(?ProdsGroup(_) + ?AssocGroup(_, _) + ?ProdsRefGroup(_) + ?AssocRefGroup(_, _))> group;
            <not(?[])> p*
        where
            new-chains := <map(create-assoc(|group, SimpleRefGroup(<id; try(remove-constructor)>), associativity); try(norm-prio-fun(|tokenize-chars)))> p*  
              
     norm-prio-fun(|tokenize-chars):
        Assoc(assocGroup@AssocGroup(_, p*), associativity, group) -> new-chains
        where
            new-chains := [<try(norm-prio-fun(|tokenize-chars))> Chain([assocGroup]), <try(norm-prio-fun(|tokenize-chars))> Assoc(ProdsGroup(p*), associativity, group)] 
     
     norm-prio-fun(|tokenize-chars):
        Assoc(assocGroup@AssocRefGroup(_, p*), associativity, group) -> new-chains
        where
            new-chains := [<try(norm-prio-fun(|tokenize-chars))> Chain([assocGroup]), <try(norm-prio-fun(|tokenize-chars))> Assoc(ProdsRefGroup(p*), associativity, group)] 
        
     norm-prio-fun(|tokenize-chars):
        Assoc(group, associativity, assocGroup@AssocGroup(_, p*)) -> new-chains
        where
            <not(?ProdsGroup(_) + ?AssocGroup(_, _) + ?ProdsRefGroup(_) + ?AssocRefGroup(_, _))> group
        where
            new-chains := [<try(norm-prio-fun(|tokenize-chars))> Chain([assocGroup]), <try(norm-prio-fun(|tokenize-chars))> Assoc(associativity, group, ProdsGroup(p*))]                       
     
     norm-prio-fun(|tokenize-chars):
        Assoc(group, associativity, assocGroup@AssocRefGroup(_, p*)) -> new-chains
        where
            <not(?ProdsGroup(_) + ?AssocGroup(_, _) + ?ProdsRefGroup(_) + ?AssocRefGroup(_, _))> group
        where
            new-chains := [<try(norm-prio-fun(|tokenize-chars))> Chain([assocGroup]), <try(norm-prio-fun(|tokenize-chars))> Assoc(associativity, group, ProdsRefGroup(p*))]                       
     

//     norm-prio-fun(|tokenize-chars):
//        Assoc(SimpleGroup(p1), associativity, SimpleGroup(p2)) -> [Chain([NonTransitive(WithArguments(SimpleGroup(p1'), Default([arity1]))), SimpleGroup(p2')]), Chain([NonTransitive(WithArguments(SimpleGroup(p2'), Default([arity2]))), SimpleGroup(p1')])]
//        where
//            <?Left() + ?Assoc()> associativity
//        where
//            p1'    := <try(remove-constructor); strip-annos> p1;
//            p2'    := <try(remove-constructor); strip-annos> p2;
//            <not(?p1')> p2';            
//            arity1 := <?SdfProduction(_, Rhs(<length; dec; int-to-string>), _)> p1';
//            arity2 := <?SdfProduction(_, Rhs(<length; dec; int-to-string>), _)> p2'
            
     norm-prio-fun(|tokenize-chars):
        Assoc(SimpleGroup(p1), associativity, SimpleGroup(p2)) -> <id>       
     
     norm-prio-fun(|tokenize-chars):
        Assoc(SimpleRefGroup(p1_ref), associativity, SimpleRefGroup(p2_ref)) -> <id>
     
     norm-prio-fun(|tokenize-chars):
        Assoc(SimpleGroup(p1), associativity, SimpleRefGroup(p2_ref)) -> <id>
     
     norm-prio-fun(|tokenize-chars):
        Assoc(SimpleRefGroup(p1_ref), associativity, SimpleGroup(p2)) -> <id>
     
     //<sortcons-to-prod(|tokenize-chars)> ref
//     norm-prio-fun(|tokenize-chars):
//        Assoc(SimpleGroup(p1), associativity, SimpleGroup(p2)) -> [Chain([NonTransitive(WithArguments(SimpleGroup(p1'), Default(["0"]))), SimpleGroup(p2')]), Chain([NonTransitive(WithArguments(SimpleGroup(p2'), Default(["0"]))), SimpleGroup(p1')])]
//        where
//            <?Right()> associativity
//        where
//            p1'    := <try(remove-constructor); strip-annos> p1;
//            p2'    := <try(remove-constructor); strip-annos> p2;
//            <not(?p1')> p2'
            
//     norm-prio-fun(|tokenize-chars):
//        Assoc(SimpleGroup(p1), associativity, SimpleGroup(p2)) -> Chain([NonTransitive(WithArguments(SimpleGroup(p1'), Default(["0"]))), SimpleGroup(p2')])
//        where
//            <?Right()> associativity
//        where
//            p1'    := <try(remove-constructor); strip-annos> p1;
//            p2'    := <try(remove-constructor); strip-annos> p2
//     
//     norm-prio-fun(|tokenize-chars):
//        Assoc(SimpleRefGroup(p1), associativity, SimpleGroup(p2)) -> Chain([NonTransitive(WithArguments(SimpleRefGroup(p1), Default(["0"]))), SimpleGroup(p2')])
//        where
//            <?Right()> associativity
//        where
//            p2'    := <try(remove-constructor); strip-annos> p2
//            
//     norm-prio-fun(|tokenize-chars):
//        Assoc(SimpleGroup(p1), associativity, SimpleRefGroup(p2)) -> Chain([NonTransitive(WithArguments(SimpleGroup(p1'), Default(["0"]))), SimpleRefGroup(p2)])
//        where
//            <?Right()> associativity
//        where
//            p1'    := <try(remove-constructor); strip-annos> p1  
//
//     norm-prio-fun(|tokenize-chars):
//        Assoc(SimpleRefGroup(p1), associativity, SimpleRefGroup(p2)) -> Chain([NonTransitive(WithArguments(SimpleRefGroup(p1), Default(["0"]))), SimpleRefGroup(p2)])
//        where
//            <?Right()> associativity
            
//     norm-prio-fun(|tokenize-chars):
//        Assoc(SimpleGroup(p1), associativity, SimpleGroup(p2)) -> [Chain([NonTransitive(SimpleGroup(p1')), SimpleGroup(p2')]), Chain([NonTransitive(SimpleGroup(p2')), SimpleGroup(p1')])]
//        where
//            <?NonAssoc()> associativity
//        where
//            p1'    := <try(remove-constructor); strip-annos> p1;
//            p2'    := <try(remove-constructor); strip-annos> p2;
//            <not(?p1')> p2';            
//            arity1 := <?SdfProduction(_, Rhs(<length; dec; int-to-string>), _)> p1';
//            arity2 := <?SdfProduction(_, Rhs(<length; dec; int-to-string>), _)> p2'
            
//     norm-prio-fun(|tokenize-chars):
//        Assoc(SimpleGroup(p1), associativity, SimpleGroup(p2)) -> [Chain([NonTransitive(WithArguments(SimpleGroup(p1'), Default(["0"]))), SimpleGroup(p2')]), Chain([NonTransitive(WithArguments(SimpleGroup(p1'), Default([arity1]))), SimpleGroup(p2')])]
//        where
//            <?NonAssoc()> associativity
//        where
//            p1'    := <try(remove-constructor); strip-annos> p1;
//            p2'    := <try(remove-constructor); strip-annos> p2;
//            arity1 := <?SdfProduction(_, Rhs(<length; dec; int-to-string>), _)> p1'
//            
//     norm-prio-fun(|tokenize-chars):
//        Assoc(SimpleRefGroup(p1), associativity, SimpleGroup(p2)) -> [Chain([NonTransitive(WithArguments(SimpleRefGroup(p1), Default(["0"]))), SimpleGroup(p2')]), Chain([NonTransitive(WithArguments(SimpleRefGroup(p1), Default([arity1]))), SimpleGroup(p2')])]
//        where
//            <?NonAssoc()> associativity
//        where
//            p1'    := <get-referenced-prod> p1;
//            p2'    := <try(remove-constructor); strip-annos> p2;
//            arity1 := <?SdfProduction(_, Rhs(<length; dec; int-to-string>), _)> p1'
//     
//     norm-prio-fun(|tokenize-chars):
//        Assoc(SimpleGroup(p1), associativity, SimpleRefGroup(p2)) -> [Chain([NonTransitive(WithArguments(SimpleGroup(p1'), Default(["0"]))), SimpleRefGroup(p2)]), Chain([NonTransitive(WithArguments(SimpleGroup(p1'), Default([arity1]))), SimpleRefGroup(p2)])]
//        where
//            <?NonAssoc()> associativity
//        where
//            p1'    := <try(remove-constructor); strip-annos> p1;
//            arity1 := <?SdfProduction(_, Rhs(<length; dec; int-to-string>), _)> p1'              
//     
//     norm-prio-fun(|tokenize-chars):
//        Assoc(SimpleRefGroup(p1), associativity, SimpleRefGroup(p2)) -> [Chain([NonTransitive(WithArguments(SimpleRefGroup(p1), Default(["0"]))), SimpleRefGroup(p2)]), Chain([NonTransitive(WithArguments(SimpleRefGroup(p1), Default([arity1]))), SimpleRefGroup(p2)])]
//        where
//            <?NonAssoc()> associativity
//        where
//            p1'    := <get-referenced-prod> p1;
//            arity1 := <?SdfProduction(_, Rhs(<length; dec; int-to-string>), _)> p1'
            
     norm-prio-fun(|tokenize-chars):
        Chain([AssocGroup(associativity, [p])]) -> <norm-prio-fun(|tokenize-chars)> Assoc(SimpleGroup(p), associativity, SimpleGroup(p))   
        
     norm-prio-fun(|tokenize-chars):
        Chain([AssocRefGroup(associativity, [p])]) -> <norm-prio-fun(|tokenize-chars)> Assoc(SimpleRefGroup(p), associativity, SimpleRefGroup(p))        
            
     norm-prio-fun(|tokenize-chars):
        Chain([AssocGroup(associativity, [first-prod | pps])]) -> new-assocs
        where
            <?[second-prod | ppss]> pps;
            <not(?[])> ppss;
            new-assocs := [<norm-prio-fun(|tokenize-chars)> Assoc(SimpleGroup(first-prod), associativity, SimpleGroup(second-prod)), 
                           <norm-prio-fun(|tokenize-chars)> Assoc(SimpleGroup(second-prod), associativity, SimpleGroup(first-prod)),
                           <norm-prio-fun(|tokenize-chars)> Chain([AssocGroup(associativity, [first-prod | ppss])]),
                           <norm-prio-fun(|tokenize-chars)> Chain([AssocGroup(associativity, [second-prod | ppss])])
                          ]
                          
     norm-prio-fun(|tokenize-chars):
        Chain([AssocRefGroup(associativity, [first-prod | pps])]) -> new-assocs
        where
            <?[second-prod | ppss]> pps;
            <not(?[])> ppss;
            new-assocs := [<norm-prio-fun(|tokenize-chars)> Assoc(SimpleRefGroup(first-prod), associativity, SimpleRefGroup(second-prod)), 
                           <norm-prio-fun(|tokenize-chars)> Assoc(SimpleRefGroup(second-prod), associativity, SimpleRefGroup(first-prod)),
                           <norm-prio-fun(|tokenize-chars)> Chain([AssocRefGroup(associativity, [first-prod | ppss])]),
                           <norm-prio-fun(|tokenize-chars)> Chain([AssocRefGroup(associativity, [second-prod | ppss])])
                          ]
            
     norm-prio-fun(|tokenize-chars):
        Chain([AssocGroup(associativity, [first-prod | pps])]) -> new-assocs
        where
            <?[second-prod | ppss]> pps;
            <?[]> ppss;
            new-assocs := [ <norm-prio-fun(|tokenize-chars)> Assoc(SimpleGroup(first-prod), associativity, SimpleGroup(second-prod)) ,
                            <norm-prio-fun(|tokenize-chars)> Assoc(SimpleGroup(second-prod), associativity, SimpleGroup(first-prod)) ]             
     
     norm-prio-fun(|tokenize-chars):
        Chain([AssocRefGroup(associativity, [first-prod | pps])]) -> new-assocs
        where
            <?[second-prod | ppss]> pps;
            <?[]> ppss;
            new-assocs := [ <norm-prio-fun(|tokenize-chars)> Assoc(SimpleRefGroup(first-prod), associativity, SimpleRefGroup(second-prod)),
                            <norm-prio-fun(|tokenize-chars)> Assoc(SimpleRefGroup(second-prod), associativity, SimpleRefGroup(first-prod))]   
     
     check-group(group) :
        NonTransitive(g) -> <check-group(group)> g
     
     check-group(group) :
        WithArguments(g, _) -> <check-group(group)> g   
     
     check-group(group) = group
      
     norm-prio-args(|tokenize-chars):
        WithArguments(SimpleGroup(p@SdfProduction(s, Rhs(rhs*), attrs*)), Default(args)) -> WithArguments(SimpleGroup(p), Default(args'))
        where
            args' := <map(update-args(|rhs*))> args
     
     norm-prio-args(|tokenize-chars):
        WithArguments(NonTransitive(SimpleGroup(p@SdfProduction(s, Rhs(rhs*), attrs*))), Default(args)) -> WithArguments(NonTransitive(SimpleGroup(p)), Default(args'))
        where      
            args' := <map(update-args(|rhs*))> args
              
     update-args(|rhs*):
        arg -> new-arg
        where
             arg' := <string-to-int> arg;
             new-arg := <count-symbols; int-to-string> (arg', -1, rhs*)
     
     count-symbols:
        (real-arg, new-arg, [h | tl]) -> new-arg'
        where
             <not(eq)> (real-arg, -1);
             if <?Cf(Opt(Layout()))> h then
                new-arg' := <count-symbols> (real-arg, <inc> new-arg, tl)
             else
                new-arg' := <count-symbols> (<dec> real-arg, <inc> new-arg, tl)
             end
             
     count-symbols:
        (-1, new-arg, [h | tl]) -> new-arg 
     
     count-symbols:
        (real-arg, new-arg, []) -> new-arg  
        
     literal-norm:
        Module(Unparameterized(mn), i*, sections*@[SDFSection(Kernel(prods*)) | ss*]) -> Module(Unparameterized(mn), i*,[SDFSection(Kernel([new-prods*, prods*])) | ss*])
        with
            literals*   := <collect(?Lit(_) + ?CiLit(_)); make-set> sections*;
            new-prods* := <map(make-prod-from-lit)> literals*
            
     make-prod-from-lit:
        l@Lit(string) -> SdfProduction(l, rhs, NoAttrs())
        with
            rhs := <un-double-quote; unescape; explode-string; filter(charclass-from-char); !Rhs(<id>)> string
            
     make-prod-from-lit:
        c@CiLit(string) -> SdfProduction(c, rhs, NoAttrs())
        with
            rhs := <unquote; unescape; explode-string; filter(charclass-from-case-insensitive); !Rhs(<id>)> string
     
     //create char-classes with numbers already instead of strings avoiding ![<id>]; implode-string;      
     charclass-from-char:
        c -> CharClass(Simple(Present(Numeric($[\[c]]))))   
     
     charclass-from-case-insensitive:
        c -> result
        with
            c1 := <try(to-upper)> c;
            c2 := <try(to-lower)> c; 
            if <?c1> c2 then
                result := CharClass(Simple(Present(Numeric($[\[c1]]))))
            else               
                result := CharClass(Simple(Present(Conc(Numeric($[\[c1]]), Numeric($[\[c2]])))))
            end
            
     //char-class-norm:
     //   m@Module(Unparameterized(mn), i*, sections*) -> m'
     //   with
     //       m' := <topdown(try(character-norm-fun)); bottomup(try(pre-char-class-norm)); char-class-norm-fun; bottomup(try(cc-set-operations)) > m
        
     character-norm-fun:
        Short(c) -> Numeric($[\[c']])
        where
            c' := <unquote; unescape; explode-string; last> c
     
     character-norm-fun:
        Top() -> Numeric($[\255])

     character-norm-fun:
        Bot() -> Numeric($[\0])
        
     character-norm-fun:
        LabelStart() -> Numeric($[\257])
        
     pre-char-class-norm:
        Range(Numeric(c1), Numeric(c2)) -> Numeric(c1)
        where
            <?c1> c2
            
     pre-char-class-norm:
        Range(Numeric(c1), Numeric(c2)) -> Absent()
        where
            <not(?c1)> c2
        where
            c1-int := <ltrim-chars(?'\'); string-to-int> c1;       
            c2-int := <ltrim-chars(?'\'); string-to-int> c2;
            <gt> (c1-int, c2-int)
            
     pre-char-class-norm:
        Present(Absent()) -> Absent()       
        
     is-member:
        (Numeric(c), Numeric(c2)) -> <id>
        where
            <?c> c2
     
     is-member:
        (Numeric(c), Range(Numeric(c1), Numeric(c2))) -> <id>
        where
            c-int  := <ltrim-chars(?'\'); string-to-int> c;
            c1-int := <ltrim-chars(?'\'); string-to-int> c1;       
            c2-int := <ltrim-chars(?'\'); string-to-int> c2;
            <geq> (c-int, c1-int);
            <geq> (c2-int, c-int)
            
     is-member:
        (c1@Numeric(c), Conc(cr1, cr2)) -> <id>
        where
            <is-member> (c1, cr1) <+ <is-member> (c1, cr2)      
            
     is-member:
        (Range(cr1@Numeric(c1), cr2@Numeric(c2)), cr) -> <id>
        where
            <is-member> (cr1, cr);
            <is-member> (Range(Numeric(<cc-succ> c1), Numeric(c2)), cr)
            
     is-member:
        (Range(cr1@Numeric(c1), Numeric(c1)), cr) -> <id>
        where
            <is-member> (cr1, cr)
            
     is-member:
        (Conc(cr1, cr2), cr) -> <id>
        where
            <is-member> (cr1, cr);
            <is-member> (cr2, cr)    
            
     is-member:
        (Absent(), cr) -> <id>         
     
     left-smaller:
        (Numeric(c1), Numeric(c3)) -> <id>
        where
            c1-int := <ltrim-chars(?'\'); string-to-int> c1;       
            c3-int := <ltrim-chars(?'\'); string-to-int> c3;
            <gt> (c3-int, c1-int)
            
     left-smaller:
        (Numeric(c1), Range(Numeric(c3), Numeric(c4))) -> <id>
        where
            c1-int := <ltrim-chars(?'\'); string-to-int> c1;       
            c3-int := <ltrim-chars(?'\'); string-to-int> c3;
            <gt> (c3-int, c1-int)
            
     left-smaller:
        (Range(Numeric(c1), Numeric(c2)), Numeric(c3)) -> <id>
        where
            c1-int := <ltrim-chars(?'\'); string-to-int> c1;       
            c3-int := <ltrim-chars(?'\'); string-to-int> c3;
            <gt> (c3-int, c1-int)
            
     left-smaller:
        (Range(Numeric(c1), Numeric(c2)), Range(Numeric(c3), Numeric(c4))) -> <id>
        where
            c1-int := <ltrim-chars(?'\'); string-to-int> c1;       
            c3-int := <ltrim-chars(?'\'); string-to-int> c3;
            <gt> (c3-int, c1-int) 
            
     smaller:
        (Numeric(c1), Numeric(c3)) -> <id>
        where
            c1-int := <ltrim-chars(?'\'); string-to-int> c1;       
            c3-int := <ltrim-chars(?'\'); string-to-int> c3;
            <gt> (c3-int, c1-int)
            
     smaller:
        (Numeric(c1), Range(Numeric(c3), Numeric(c4))) -> <id>
        where
            c1-int := <ltrim-chars(?'\'); string-to-int> c1;       
            c3-int := <ltrim-chars(?'\'); string-to-int> c3;
            <gt> (c3-int, c1-int)
            
     smaller:
        (Range(Numeric(c1), Numeric(c2)), Numeric(c3)) -> <id>
        where
            c2-int := <ltrim-chars(?'\'); string-to-int> c2;       
            c3-int := <ltrim-chars(?'\'); string-to-int> c3;
            <gt> (c3-int, c2-int)
            
     smaller:
        (Range(Numeric(c1), Numeric(c2)), Range(Numeric(c3), Numeric(c4))) -> <id>
        where
            c2-int := <ltrim-chars(?'\'); string-to-int> c2;       
            c3-int := <ltrim-chars(?'\'); string-to-int> c3;
            <gt> (c3-int, c2-int)       
            
     strictly-smaller:
        (Numeric(c1), Numeric(c3)) -> <id>
        where
            c1-int := <ltrim-chars(?'\'); string-to-int> c1;       
            c3-int := <ltrim-chars(?'\'); string-to-int> c3;
            <gt> (c3-int, <inc> c1-int)
            
     strictly-smaller:
        (Numeric(c1), Range(Numeric(c3), Numeric(c4))) -> <id>
        where
            c1-int := <ltrim-chars(?'\'); string-to-int> c1;       
            c3-int := <ltrim-chars(?'\'); string-to-int> c3;
            <gt> (c3-int, <inc> c1-int)
            
     strictly-smaller:
        (Range(Numeric(c1), Numeric(c2)), Numeric(c3)) -> <id>
        where
            c2-int := <ltrim-chars(?'\'); string-to-int> c2;       
            c3-int := <ltrim-chars(?'\'); string-to-int> c3;
            <gt> (c3-int, <inc> c2-int)
            
     strictly-smaller:
        (Range(Numeric(c1), Numeric(c2)), Range(Numeric(c3), Numeric(c4))) -> <id>
        where
            c2-int := <ltrim-chars(?'\'); string-to-int> c2;       
            c3-int := <ltrim-chars(?'\'); string-to-int> c3;
            <gt> (c3-int, <inc> c2-int)                                     
      
     char-class-norm-fun = bottomup(try(order-ranges)); bottomup(try(merge-overlapping-cc))
      
     order-ranges:
        Conc(r1, r2) -> Conc(r2, r1)
        where
            <not(?Conc(_, _))> r2
        where
            <left-smaller> (r2, r1)     
            
     order-ranges:
        Conc(r1, rt) -> Conc(r2, <try(order-ranges)> Conc(r1, rtt))
        where
            <?Conc(r2, rtt)> rt
        where
            <left-smaller> (r2, r1)          
     
     merge-overlapping-cc:
        Conc(r1, r2) -> r3
        where
            <not(?Conc(_, _))> r2
        where
            r3 := <merge-cc> (r1, r2)
            
     merge-overlapping-cc:
        Conc(r1, rt) -> <try(merge-overlapping-cc)> Conc(r3, rtt)
        where
            <?Conc(r2, rtt)> rt
        where
            r3 := <merge-cc> (r1, r2)   
            
     merge-overlapping-cc:
        Conc(r1, r2) -> r1
        where
        <?Absent()> r2
        
     merge-overlapping-cc:
        Conc(r1, r2) -> r2
        where
        <?Absent()> r1       
            
     merge-cc:
        (Numeric(c), Numeric(c)) -> Numeric(c)
        
     merge-cc:
        (Numeric(c1), Numeric(c2)) -> Range(Numeric(c1), Numeric(c2))
        where
            c1-int := <ltrim-chars(?'\'); string-to-int> c1;       
            c2-int := <ltrim-chars(?'\'); string-to-int> c2;
            <eq> (c2-int, <inc> c1-int)
            
     merge-cc:
        (Range(Numeric(c1), Numeric(c2)), Numeric(c3)) -> Range(Numeric(c1), Numeric(<max-character> (c2, c3)))
        where
            c1-int := <ltrim-chars(?'\'); string-to-int> c1;       
            c2-int := <ltrim-chars(?'\'); string-to-int> c2;
            c3-int := <ltrim-chars(?'\'); string-to-int> c3;
            <geq> (c3-int, c1-int);
            <geq> (<inc> c2-int, c3-int)   
            
     merge-cc:
        (Numeric(c1), Range(Numeric(c2), Numeric(c3))) -> Range(Numeric(c1), Numeric(c3))
        where
            c1-int := <ltrim-chars(?'\'); string-to-int> c1;       
            c2-int := <ltrim-chars(?'\'); string-to-int> c2;
            c3-int := <ltrim-chars(?'\'); string-to-int> c3;
            <eq <+ <eq> (<inc> c1-int, c2-int) > (c1-int, c2-int) 
     
     merge-cc:
        (Range(Numeric(c1), Numeric(c2)), Range(Numeric(c3), Numeric(c4))) -> Range(Numeric(c1), Numeric(<max-character> (c2, c4)))
        where
            c1-int := <ltrim-chars(?'\'); string-to-int> c1;       
            c2-int := <ltrim-chars(?'\'); string-to-int> c2;
            c3-int := <ltrim-chars(?'\'); string-to-int> c3;
            <geq> (c3-int, c1-int);
            <geq> (<inc> c2-int, c3-int)
           
     
     max-character:
        (c1, c2) -> result
        where
            c1-int := <ltrim-chars(?'\'); string-to-int> c1;       
            c2-int := <ltrim-chars(?'\'); string-to-int> c2;
            if <gt> (c1-int, c2-int) then
                result := c1
            else
                result := c2
            end  
                          
     cc-set-operations:
        Union(cc1, cc2) -> cc2
        where
            <?Simple(Absent())> cc1
            
     cc-set-operations:
        Union(cc1, cc2) -> cc1
        where
            <?Simple(Absent())> cc2
            
     cc-set-operations:
        Union(cc1, cc2) -> result
        where
            <not(?Simple(Absent()))> cc1;
            <not(?Simple(Absent()))> cc2              
        with
            result := <try(concatenate-cc)> (cc1, cc2)
     
     //diff of empty sets       
     cc-set-operations:
        Diff(cc1, cc2) -> cc1
        where
             <?Simple(Absent())> cc2
             
     cc-set-operations:
        Diff(cc1, cc2) -> cc1
        where
            <?Simple(Absent())> cc1
   
     //diff of single character ranges
     cc-set-operations:
        Diff(cc1, cc2) -> result
        where
            <?Simple(Present(Numeric(c1)))> cc1;
            <?Simple(Present(Numeric(c2)))> cc2;
            if <?c1> c2 then
                result := Simple(Absent())
            else
                result := cc1
            end
     
     cc-set-operations:
        Diff(cc1, cc2) -> result
        where
            <?Simple(Present(Numeric(c1)))> cc1;
            <?Simple(Present(Range(Numeric(c3), Numeric(c4))))> cc2;
            c1-int := <ltrim-chars(?'\'); string-to-int> c1;       
            c3-int := <ltrim-chars(?'\'); string-to-int> c3;
            c4-int := <ltrim-chars(?'\'); string-to-int> c4;            
            if <geq> (c1-int, c3-int); <geq> (c4-int, c1-int)  then
                result := Simple(Absent())
            else
                result := cc1
            end
            
     cc-set-operations:
        Diff(cc1, cc2) -> result
        where
            <?Simple(Present(Range(Numeric(c1), Numeric(c2))))> cc1;
            <?Simple(Present(Numeric(c3)))> cc2;
            c1-int := <ltrim-chars(?'\'); string-to-int> c1;       
            c2-int := <ltrim-chars(?'\'); string-to-int> c2;
            c3-int := <ltrim-chars(?'\'); string-to-int> c3;            
            if <geq> (c3-int, c1-int); <geq> (c2-int, c3-int)  then
                result := Simple(<try(merge-overlapping-cc); (?Absent() <+ !Present(<id>))> Conc(<try(pre-char-class-norm)> Range(Numeric(c1), Numeric(<cc-pred> c3))
                                            , <try(pre-char-class-norm)> Range(Numeric(<cc-succ> c3), Numeric(c2))))
            else
                result := cc1
            end       
      
      cc-set-operations:
        Diff(cc1, cc2) -> result
        where
            <?Simple(Present(Range(Numeric(c1), Numeric(c2))))> cc1;
            <?Simple(Present(Range(Numeric(c3), Numeric(c4))))> cc2;
            c1-int := <ltrim-chars(?'\'); string-to-int> c1;       
            c2-int := <ltrim-chars(?'\'); string-to-int> c2;
            c3-int := <ltrim-chars(?'\'); string-to-int> c3;
            c4-int := <ltrim-chars(?'\'); string-to-int> c4;
            c4'    := <cc-succ> c4;
            c4-int':= <ltrim-chars(?'\'); string-to-int> c4';
            if <geq> (c2-int, c3-int); <geq> (c4-int', c1-int)  then
                result := Simple(<try(merge-overlapping-cc); (?Absent() <+ !Present(<id>))> Conc(<try(pre-char-class-norm)> Range(Numeric(c1), Numeric(<cc-pred> c3))
                                            , <try(pre-char-class-norm)> Range(Numeric(c4'), Numeric(c2))))
            else
                result := cc1
            end
      
      cc-set-operations:
        d@Diff(Simple(Present(cr1)), Simple(Present(cr2))) -> result
        where
            <?Conc(_, _)> cr1 <+
            <?Conc(_, _)> cr2
        where
            <smaller> (<cc-head> cr2, <cc-head> cr1);
            result-tail-cr2 := <cc-tail; (?Absent(); !Simple(<id>) <+ !Simple(Present(<id>)))> cr2;
            result :=  <cc-set-operations> Diff(Simple(Present(cr1)), result-tail-cr2)   
            
      cc-set-operations:
        d@Diff(Simple(Present(cr1)), Simple(Present(cr2))) -> result
        where
            <?Conc(_, _)> cr1 <+
            <?Conc(_, _)> cr2
        where
            <smaller> (<cc-head> cr1, <cc-head> cr2);
            result-tail-cc1 := <cc-tail; (?Absent(); !Simple(<id>) <+ !Simple(Present(<id>)))> cr1;
            result :=  <bottomup(try(cc-set-operations))> Union(Simple(Present(<cc-head> cr1)), Diff(result-tail-cc1, Simple(Present(cr2))))         
      
      cc-set-operations:
        d@Diff(Simple(Present(cr1)), Simple(Present(cr2))) -> result
        where
            <?Conc(_, _)> cr1 <+
            <?Conc(_, _)> cr2
        where
            cr1-head := <cc-head> cr1;
            cr2-head := <cc-head> cr2;
            not(<smaller> (cr1-head, cr2-head) <+ <smaller> (cr2-head, cr1-head));
            tail-cr1 := <cc-tail; (?Absent(); !Simple(<id>) <+ !Simple(Present(<id>)))> cr1;
            tail-cr2 := <cc-tail; (?Absent(); !Simple(<id>) <+ !Simple(Present(<id>)))> cr2;
            result := <bottomup(try(cc-set-operations))> Diff(Union(Diff(Simple(Present(cr1-head)), Simple(Present(cr2-head))), tail-cr1), Union(Diff(Simple(Present(cr2-head)), Simple(Present(cr1-head))), tail-cr2))   
      
      cc-set-operations:
        Comp(cc) -> Simple(Present(Range(Numeric("\\0"), Numeric("\\255"))))
        where
            <?Simple(Absent())> cc
            
      cc-set-operations:
        Comp(cc) -> <cc-set-operations> Diff(Simple(Present(Range(Numeric("\\0"), Numeric("\\255")))), cc)
        where
            <not(?Simple(Absent()))> cc   
            
      cc-set-operations:
        Isect(cc1, cc2) -> <bottomup(try(cc-set-operations))> Diff(cc1, Diff(cc1, cc2))      
      
      concatenate-cc:
        p@(Simple(Present(r1)), cr3@Simple(Present(r2))) -> result
        where
            cr1       := <cc-head> r1;
            <strictly-smaller> (cr1, <cc-head> r2);
            tail-cr1  := <cc-tail; (?Absent(); !Simple(<id>) <+ !Simple(Present(<id>)))> r1;
            cr2cr3    := <concatenate-cc> (tail-cr1, cr3);
            remainder := <?Simple(Present(<id>))> cr2cr3;
            result    := Simple(Present(Conc(cr1, remainder)))
      
      concatenate-cc:
        (Simple(Present(r1)), Simple(Present(r2))) -> <try(concatenate-cc)> (Simple(Present(r2)), Simple(Present(r1)))
        where
            <left-smaller> (<cc-head> r2, <cc-head> r1)
            
      concatenate-cc:
        (Simple(Present(r1)), Simple(Present(r2))) -> <try(concatenate-cc)> (<try(concatenate-cc)> (r3, result-tail-r1), result-tail-r2)
        where
            result-tail-r1 := <cc-tail; (?Absent(); !Simple(<id>) <+ !Simple(Present(<id>)))> r1;
            result-tail-r2 := <cc-tail; (?Absent(); !Simple(<id>) <+ !Simple(Present(<id>)))> r2;
            r3             := Simple(Present(<merge-cc> (<cc-head> r1, <cc-head> r2)))
                  
      concatenate-cc:
        (Simple(Present(r1)), Simple(Absent())) -> Simple(Present(r1))
        
      concatenate-cc:
        (Simple(Absent()), Simple(Present(r2))) -> Simple(Present(r2))   
        
      concatenate-cc:
        (Simple(Absent()), Simple(Absent())) -> Simple(Absent())
                        
      cc-head:
        cr -> <id>
        where
        not(?Conc(c1, _))
        
      cc-head:
        Conc(c1, _)-> c1
        
      cc-tail:
        cr -> Absent()
        where
        not(?Conc(c1, _))
        
      cc-tail:
        Conc(c1, cr)-> cr  
        
      cc-succ:
        char -> char'
        where
            int-succ-char :=  <ltrim-chars(?'\'); string-to-int; inc> char;
            char'         :=  $[\[int-succ-char]]
     
     cc-pred:
        char -> char'
        where
            int-pred-char :=  <ltrim-chars(?'\'); string-to-int; dec> char;
            char'         :=  $[\[int-pred-char]]       
     
     restrictions-norm:
        Module(Unparameterized(mn), i*, [kernel | sections*]) -> Module(Unparameterized(mn), i*, [kernel, new-restrictions, priorities])
        where
            priorities           := <last> sections*;
            sections'*           := <filter(not(?Kernel(_) + ?SDFSection(Priorities(_))))> sections*;
            cf-restrictions*     := <filter(?SDFSection(ContextFreeRestrictions(<id>))); flatten-list; map(try(cf-to-kernel-restriction))> sections*;
            lex-restrictions*    := <filter(?SDFSection(LexicalRestrictions(<id>))); flatten-list; map(try(lex-to-kernel-restriction))> sections*;
            kernel-restrictions* := <filter(?SDFSection(Restrictions(<id>))); flatten-list> sections*;
            new-restrictions     := SDFSection(Restrictions(<merge-restrictions> [cf-restrictions*, lex-restrictions*, kernel-restrictions*]))
                           
     merge-restrictions :
        restrictions* -> merged-restrictions*
        where
            restriction-symbols* := <map(?Follow(<id>, _)); flatten-list; make-set> restrictions*;            
            merged-restrictions* := <map(make-new-restrictions(|restrictions*))> restriction-symbols*
     
     make-new-restrictions(|restrictions*):
        symbol -> new-restriction
        where
            char-set                := <filter(char-set-from-restr(|symbol)); try(flatten-list); create-char-set-from-list; bottomup(try(cc-set-operations))> restrictions*;
            seqs*                   := <filter(seq-from-restr(|symbol)); flatten-list; bottomup(try(add-lists-to-sequences))> restrictions*;
            seqs-symbols*           := <map(?Seq(<id>,_)); flatten-list; make-set> seqs*;
            merged-seqs*            := <map(make-new-seqs(|seqs*))> seqs-symbols*;
            if <?[]> seqs* then
                new-restriction     := Follow([symbol], List([CharClass(char-set)]))
            else
                if <?Simple(Absent())> char-set then
                    new-restriction := Follow([symbol], List(merged-seqs*))
                else
                    new-restriction := Follow([symbol], List(<make-set> [CharClass(char-set), merged-seqs*]))
                end
            end
            
     make-new-seqs(|seqs*):
        symbol -> new-seq
        with
            list-elems* := <filter(elems-from-seq-list(|symbol)); flatten-list> seqs*;
            new-seq     := Seq(symbol, List(<make-set> list-elems*))
     
     elems-from-seq-list(|s):
        Seq(h, List(elems*)) -> elems*
        where
            <?s> h         
                    
     char-set-from-restr(|s):
        Follow(symbols*, la) -> result
        where
          <fetch(?s)> symbols*
      where
          result := <char-set-from-la> la
          
   seq-from-restr(|s):
        Follow(symbols*, la) -> result
        where
            <fetch(?s)> symbols*;
            result := <collect(?Single(Seq(_, _)) <+ ?Seq(_, _))> la       
          
   char-set-from-la:
      List(rest*) -> result
      where
         result := <filter(char-set-from-la)> rest*
        
     char-set-from-la:
        Single(c@CharClass(_)) -> [c]
        
     char-set-from-la:
        c@CharClass(_) -> [c]   
    
     char-set-from-la:
        Alt(a1, a2) -> result
        where
            result := [<char-set-from-la> a1, <char-set-from-la> a2]    
    
     char-set-from-la:
        Single(Seq(h, tl)) -> []        
        
     add-lists-to-sequences:
        Single(s@Seq(h, tl)) -> s     
    
     add-lists-to-sequences:
        Seq(h, tl) -> Seq(h, List([tl']))
        where
            <not(?List(_))> tl;
            tl' := <try(char-set-from-la; flatten-list; create-char-set-from-list; bottomup(try(cc-set-operations)); !CharClass(<id>))> tl
            
     add-lists-to-sequences:
        Seq(h, tl) -> Seq(h, tl)
        where
            <?List(_)> tl         
                  
     create-char-set-from-list:
        [h | hs] -> Union(result, <?CharClass(<id>)> h)
        where
            result := <create-char-set-from-list> hs            
     
     create-char-set-from-list:
        [] -> Simple(Absent())
         
     cf-to-kernel-restriction :
        Follow(symbols*, la) -> Follow(symbols'*, la)
        where
            symbols'* := <map(try(cf-norm-symb))> symbols*
            
     lex-to-kernel-restriction:
        Follow(symbols*, la) -> Follow(symbols'*, la)
        where
            symbols'* := <map(try(lex-norm-symb); ?(<id>, _) )> symbols*        
     
            
     // remove the constructor from all productions to avoid duplicate definitions
     // at some point maybe we should disallow undefined productions in the priorities, but I don't know 
     // how it would affect the normalized grammar 
     remove-constructor:
        SdfProductionWithCons(SortCons(symbol, Constructor(cons)), rhs@Rhs(symbols*), attrs) -> SdfProduction(symbol, rhs, attrs)
             
     create-gt-chain(|g1, g2) = !Chain([g1, g2])
     
     create-assoc(|g1, g2, associativity) = !Assoc(g1, associativity, g2)
     
     replace-sort-def :
       SortDef(s) -> Sort(s)                