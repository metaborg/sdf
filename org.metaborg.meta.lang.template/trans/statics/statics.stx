module statics/statics

signature
  
  // Modules
  sorts Module constructors
    Module : ModuleName * list(ImpSection) * list(Section) -> Module

  sorts ModuleName constructors
    Unparameterized : ModuleId      -> ModuleName
    Parameterized   : ModuleId * () -> ModuleName

  sorts ModuleId constructors
    Leaf : string            -> ModuleId
    Root : string            -> ModuleId
    Path : string * ModuleId -> ModuleId
 
 
  // Imports
  sorts ImpSection constructors
    Imports : list(Import) -> ImpSection
  
  sorts Import constructors
    Module : ModuleName -> Import


  // Sections
  sorts Section constructors
    SDFSection      : Grammar                  -> Section
    TemplateSection : list(TemplateProduction) -> Section
    TemplateOptions : list(TemplateOption)     -> Section


  // Grammar
  sorts Grammar


  // Syntax productions
  constructors
    Syntax            : list(Production)        -> Grammar // TODO: add constraint
    Kernel            : list(SdfProduction)     -> Grammar
    LexicalSyntax     : list(SdfProduction)     -> Grammar
    ContextFreeSyntax : list(GeneralProduction) -> Grammar
    
  sorts Production constructors // Kernel-style productions // TODO: add constraints
    Prod : list(Symbol) * Symbol * Attributes -> Production

  sorts GeneralProduction constructors // General productions (explicated injection)
    GeneralProduction_SdfProduction      : SdfProduction      -> GeneralProduction
    GeneralProduction_TemplateProduction : TemplateProduction -> GeneralProduction

  sorts SdfProduction constructors // SDF2-style productions
    SdfProduction         : SymbolDef * RHS * Attributes -> SdfProduction
    SdfProductionWithCons : SortCons  * RHS * Attributes -> SdfProduction    

  sorts TemplateProduction constructors // SDF3-style productions
    TemplateProduction         : SymbolDef * Template * Attributes -> TemplateProduction
    TemplateProductionWithCons : SortCons  * Template * Attributes -> TemplateProduction


  // Template production
  sorts Template constructors
    Template       : list(TemplateLine) -> Template
    TemplateSquare : list(TemplateLine) -> Template
    
  sorts TemplateLine constructors
    Line : list(TemplatePart) -> TemplateLine
    
  sorts TemplatePart constructors
    Angled  : Placeholder -> TemplatePart
    Squared : Placeholder -> TemplatePart
    
  sorts Placeholder constructors
    Placeholder : Symbol * PlaceholderOptions -> Placeholder
    
    
  // Template options
  sorts TemplateOption constructors
    KeywordAttributes : SymbolDef * Attributes -> TemplateOption // TODO: add constraint
    // Ignore other template options, as they do not contain names nor types.


  // Start symbols grammar sections
  constructors
    KernelStartSymbols      : list(Symbol) -> Grammar
    LexicalStartSymbols     : list(Symbol) -> Grammar
    ContextFreeStartSymbols : list(Symbol) -> Grammar


  // Priorities grammar sections
  constructors
    Priorities             : list(Priority) -> Grammar // TODO: add constraint
    LexicalPriorities      : list(Priority) -> Grammar // TODO: add constraint
    ContextFreePriorities  : list(Priority) -> Grammar // TODO: add constraint
  
  sorts Priority constructors // TODO: add constraints
    Chain : list(Group)                   -> Priority
    Assoc : Group * Associativity * Group -> Priority
    
  sorts Group constructors // TODO: add constraints
    WithArguments : Group * ArgumentIndicator                -> Group
    NonTransitive : Group                                    -> Group
    SimpleGroup   : PriorityProduction                       -> Group
    ProdsGroup    : list(PriorityProduction)                 -> Group
    AssocGroup    : Associativity * list(PriorityProduction) -> Group
    
  sorts PriorityProduction constructors // TODO: explicate injection and add constraints
    PriorityProduction_SdfProduction : SdfProduction -> PriorityProduction
    PriorityProduction_Production : Production -> PriorityProduction
  
  
  // Restrictions grammar sections
  constructors
    Restrictions            : list(Restriction) -> Grammar // TODO: add constraint
    LexicalRestrictions     : list(Restriction) -> Grammar // TODO: add constraint
    ContextFreeRestrictions : list(Restriction) -> Grammar // TODO: add constraint
    
  sorts Restriction constructors
    Follow : list(Symbol) * Lookaheads -> Restriction // TODO: add constraint


  // Sorts and Constructors
  sorts SortCons constructors
    SortCons : SymbolDef * Constructor -> SortCons
    
  sorts Constructor constructors
    Constructor : string -> Constructor
    
  sorts SymbolDef constructors
    SortDef      : string    -> SymbolDef
    SymbolDefCf  : SymbolDef -> SymbolDef
    SymbolDefLex : SymbolDef -> SymbolDef
    Var          : SymbolDef -> SymbolDef


  // Symbols  
  sorts Symbol constructors
    Cf     : Symbol -> Symbol
    Lex    : Symbol -> Symbol
    Varsym      : Symbol -> Symbol
    Label       : Label * Symbol -> Symbol
    Sequence    : Symbol * Symbol -> Symbol
    Opt         : Symbol -> Symbol
    Iter        : Symbol -> Symbol
    IterStar    : Symbol -> Symbol
    IterSep     : Symbol * Separator -> Symbol
    IterStarSep : Symbol * Separator -> Symbol
    Alt         : Symbol * Symbol -> Symbol
    Sort              : string -> Symbol
    ParameterizedSort : string * list(Symbol) -> Symbol
    // Ignore other symbols, as they do not contain names nor types.
  
  sorts RHS constructors
    Rhs : list(Symbol) -> RHS



  // Labels
  sorts Label constructors // TODO
  
  
  // Ignore following sorts, as they do not contain names nor types.
  sorts Associativity
  sorts ArgumentIndicator
  sorts PlaceholderOptions
  sorts Separator
  sorts Attributes
  sorts Lookaheads
  
  
  // Sort type
  sorts SORT constructors
    DEF : occurrence -> SORT

  relations
    sortOfDecl : occurrence -> SORT


  // Namespaces
  namespaces
    Module      : ModuleId
    Sort        : string
    Constructor : string
    Label       : string

  // Resolution
  name-resolution
    labels P
    resolve Module      filter P* min $ < P
    resolve Sort        filter P* min $ < P
    resolve Constructor filter P* min $ < P
    resolve Label       filter P* min $ < P

rules // Project

  projectOK : scope

  projectOK(s).

rules // File

  fileOK : scope * Module
  fileOK(s, Module(name, importSections, sections)) :- 
    declareModule(s, name),
    importSectionsOK(s, importSections),
    sectionsOK(s, sections).

  importSectionOK : scope * ImpSection
  importSectionOK(s, Imports(imports)) :- importsOK(s, imports).
  importSectionsOK maps importSectionOK(*, list(*))
  
  importOK : scope * Import
  importOK(s, Module(name)) :- resolveModule(s, name). // TODO: add import
  importsOK maps importOK(*, list(*))

  sectionOK: scope * Section
  sectionOK(s, SDFSection(grammar)) :- grammarOK(s, grammar).
  sectionOK(s, TemplateSection(templateProductions)) :- templateProductionsOK(s, templateProductions).
  sectionOK(s, TemplateOptions(templateOptions)).
  sectionsOK maps sectionOK(*, list(*))
  
  grammarOK: scope * Grammar
  grammarOK(s, Kernel(productions)) :- sdfProductionsOK(s, productions).
  grammarOK(s, LexicalSyntax(productions)) :- sdfProductionsOK(s, productions).
  grammarOK(s, ContextFreeSyntax(generalProductions)) :- generalProductionsOK(s, generalProductions).
  grammarOK(s, KernelStartSymbols(symbols)) :- symbolsOK(s, symbols).
  grammarOK(s, LexicalStartSymbols(symbols)) :- symbolsOK(s, symbols).
  grammarOK(s, ContextFreeStartSymbols(symbols)) :- symbolsOK(s, symbols).
  
  generalProductionOK: scope * GeneralProduction
  generalProductionOK(s, GeneralProduction_SdfProduction(sdfProduction)) :- sdfProductionOK(s, sdfProduction).
  generalProductionOK(s, GeneralProduction_TemplateProduction(templateProduction)) :- templateProductionOK(s, templateProduction).
  generalProductionsOK maps generalProductionOK(*, list(*))
  
  sdfProductionOK: scope * SdfProduction
  sdfProductionOK(s, SdfProduction(symbolDef, rhs, _)) :-
    symbolDefOK(s, symbolDef),
    rhsOK(s, rhs).
  sdfProductionOK(s, SdfProductionWithCons(sortCons, rhs, _)) :-
    sortConsOK(s, sortCons),
    rhsOK(s, rhs).
  sdfProductionsOK maps sdfProductionOK(*, list(*))
  
  rhsOK: scope * RHS
  rhsOK(s, Rhs(symbols)) :- symbolsOK(s, symbols).
  
  templateProductionOK: scope * TemplateProduction
  templateProductionOK(s, TemplateProduction(symbolDef, template, _)) :-
    symbolDefOK(s, symbolDef),
    templateOK(s, template).
  templateProductionOK(s, TemplateProductionWithCons(sortCons, template, _)) :-
    sortConsOK(s, sortCons),
    templateOK(s, template).
  templateProductionsOK maps templateProductionOK(*, list(*))

  templateOK: scope * Template
  templateOK(s, Template(lines)) :- templateLinesOK(s, lines).
  templateOK(s, TemplateSquare(lines)) :- templateLinesOK(s, lines).
  
  templateLineOK: scope * TemplateLine
  templateLineOK(s, Line(parts)) :- templatePartsOK(s, parts).
  templateLinesOK maps templateLineOK(*, list(*))
  
  templatePartOK: scope * TemplatePart
  templatePartOK(s, Angled(placeholder)) :- placeholderOK(s, placeholder).
  templatePartOK(s, Squared(placeholder)) :- placeholderOK(s, placeholder).
  templatePartOK(s, _). // Other template parts do not contain names nor types.
  templatePartsOK maps templatePartOK(*, list(*))
  
  placeholderOK: scope * Placeholder
  placeholderOK(s, Placeholder(symbol, _)) :- symbolOK(s, symbol).

rules // SortCons and Constructor

  sortConsOK: scope * SortCons
  sortConsOK(s, SortCons(symbolDef, constructor)) :-
    symbolDefOK(s, symbolDef),
    constructorOK(s, constructor).
  
  constructorOK: scope * Constructor
  constructorOK(s, Constructor(name)) :-
    declareConstructor(s, name).
  
rules // Symbol

  symbolOK: scope * Symbol
  symbolOK(s, Cf(symbol)) :- symbolOK(s, symbol).
  symbolOK(s, Lex(symbol)) :- symbolOK(s, symbol).
  symbolOK(s, Varsym(symbol)) :- symbolOK(s, symbol).
  symbolOK(s, Label(label, symbol)) :- symbolOK(s, symbol). // TODO: label
  symbolOK(s, Sequence(symbol1, symbol2)) :- symbolOK(s, symbol1), symbolOK(s, symbol2).
  symbolOK(s, Opt(symbol)) :- symbolOK(s, symbol).
  symbolOK(s, Iter(symbol)) :- symbolOK(s, symbol).
  symbolOK(s, IterStar(symbol)) :- symbolOK(s, symbol).
  symbolOK(s, IterSep(symbol, _)) :- symbolOK(s, symbol).
  symbolOK(s, IterStarSep(symbol, _)) :- symbolOK(s, symbol).
  symbolOK(s, Alt(symbol1, symbol2)) :- symbolOK(s, symbol1), symbolOK(s, symbol2).
  symbolOK(s, Sort(name)) :- resolveSort(s, name).
  symbolOK(s, ParameterizedSort(name, symbols)) :- resolveSort(s, name), symbolsOK(s, symbols).
  symbolOK(s, _). // Other symbols do not contain names nor types.
  symbolsOK maps symbolOK(*, list(*))

rules // SymbolDef

  symbolDefOK: scope * SymbolDef
  symbolDefOK(s, SortDef(name))  :- declareSort(s, name).
  symbolDefOK(s, SymbolDefCf(symbolDef))  :- symbolDefOK(s, symbolDef).
  symbolDefOK(s, SymbolDefLex(symbolDef)) :- symbolDefOK(s, symbolDef).
  symbolDefOK(s, Var(symbolDef)) :- symbolDefOK(s, symbolDef).
  symbolDefOK(s, _). // Other symbol definitions do not contain names nor types.

rules // Constructors

  // TODO: constructors should be typed as sort -> sort*, and they must be unique within that name+type.

  declareConstructor : scope * string  
  declareConstructor(s, name) :-
    s -> Constructor{name},
    Constructor{name} in s |-> [(_, (_))] | error $[Duplicate definition of constructor [name]].
    
  resolveConstructor : scope * string
  resolveConstructor(s, name)  :- {name'}
    Constructor{name} in s |-> [(_, (Constructor{name'}))|_]| error $[Constructor [name] not defined],
    @name.ref := name'.

rules // Sorts

  declareSort : scope * string  
  declareSort(s, name) :-
    s -> Sort{name}.
    
  resolveSort : scope * string
  resolveSort(s, name)  :- {name'}
    Sort{name} in s |-> [(_, (Sort{name'}))|_]| error $[Sort [name] not defined],
    @name.ref := name'.

rules // Modules

  declareModule : scope * ModuleName  
  declareModule(s, name) :- {id}
    idOfModuleName(name) == id, 
    s -> Module{id},
    Module{id} in s |-> [(_, (_))] | error $[Duplicate definition of module [id]].

  resolveModule : scope * ModuleName
  resolveModule(s, name)  :- {id id'}
    idOfModuleName(name) == id, 
    Module{id} in s |-> [(_, (Module{id'}))|_]| error $[Module [id] not defined],
    @id.ref := id'.

  idOfModuleName : ModuleName -> ModuleId
  idOfModuleName(Unparameterized(id))  = id.
  idOfModuleName(Parameterized(id, _)) = id.
