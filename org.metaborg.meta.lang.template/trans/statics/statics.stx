module statics/statics

//
// Name-resolution
//

signature

  namespaces
    Module      : ModuleId
    Sort        : string
    Constructor : string
    Label       : string

  name-resolution
    labels P
    resolve Module      filter P* min $ < P
    resolve Sort        filter P* min $ < P
    resolve Constructor filter P* min $ < P
    resolve Label       filter P* min $ < P

//
// Projects
//

rules

  projectOK : scope
  projectOK(s).

//
// Modules
//

signature 

  sorts Module constructors
    Module : ModuleName * list(ImpSection) * list(Section) -> Module

  sorts ModuleName constructors
    Unparameterized : ModuleId                -> ModuleName
    Parameterized   : ModuleId * list(Symbol) -> ModuleName

  sorts ModuleId // Use module identifiers as-is.

rules

  moduleOK : scope * Module
  moduleOK(s, Module(name, importSections, sections)) :-
    moduleNameOK(s, name),
    declareModule(s, name),
    importSectionsOK(s, importSections),
    sectionsOK(s, sections).
    
  moduleNameOK : scope * ModuleName
  moduleNameOK(s, Parameterized(_, symbols)) :- symbolsOK(s, symbols).    
  moduleNameOK(s, _).

rules

  declareModule : scope * ModuleName  
  declareModule(s, name) :- {id}
    idOfModuleName(name) == id, 
    s -> Module{id},
    Module{id} in s |-> [(_, (_))] | error $[Duplicate definition of module [id]].

  resolveModule : scope * ModuleName
  resolveModule(s, name)  :- {id id'}
    idOfModuleName(name) == id, 
    Module{id} in s |-> [(_, (Module{id'}))|_]| error $[Module [id] not defined],
    @id.ref := id'.

  idOfModuleName : ModuleName -> ModuleId
  idOfModuleName(Unparameterized(id))  = id.
  idOfModuleName(Parameterized(id, _)) = id.

//
// Module imports
//

signature

  sorts ImpSection constructors
    Imports : list(Import) -> ImpSection
  
  sorts Import constructors
    Module : ModuleName -> Import

rules

  importSectionOK : scope * ImpSection
  importSectionOK(s, Imports(imports)) :- importsOK(s, imports).
  importSectionsOK maps importSectionOK(*, list(*))
  
  importOK : scope * Import
  importOK(s, Module(name)) :- resolveModule(s, name). // TODO: add import
  importsOK maps importOK(*, list(*))

//
// Sections
//

signature
  
  sorts Section

rules

  sectionOK: scope * Section
  sectionsOK maps sectionOK(*, list(*))

//
// SDF (grammar) section
//

signature

  sorts Grammar

  constructors
    SDFSection : Grammar -> Section

rules

  grammarOK: scope * Grammar
  
  sectionOK(s, SDFSection(grammar)) :- grammarOK(s, grammar).

//
// Template productions section
//

signature

  constructors
    TemplateSection : list(TemplateProduction) -> Section

  sorts TemplateProduction constructors
    TemplateProduction         : SymbolDef * Template * Attributes -> TemplateProduction
    TemplateProductionWithCons : SortCons  * Template * Attributes -> TemplateProduction

  sorts Template constructors
    Template       : list(TemplateLine) -> Template
    TemplateSquare : list(TemplateLine) -> Template

  sorts TemplateLine constructors
    Line : list(TemplatePart) -> TemplateLine

  sorts TemplatePart constructors
    Angled  : Placeholder -> TemplatePart
    Squared : Placeholder -> TemplatePart

  sorts Placeholder constructors
    Placeholder : Symbol * PlaceholderOptions -> Placeholder

  sorts Attributes
  sorts PlaceholderOptions

rules

  sectionOK(s, TemplateSection(templateProductions)) :- templateProductionsOK(s, templateProductions).
  
  templateProductionOK: scope * TemplateProduction
  templateProductionOK(s, TemplateProduction(symbolDef, template, _)) :-
    symbolDefOK(s, symbolDef),
    templateOK(s, template).
  templateProductionOK(s, TemplateProductionWithCons(sortCons, template, _)) :-
    sortConsOK(s, sortCons),
    templateOK(s, template).
  templateProductionsOK maps templateProductionOK(*, list(*))

  templateOK: scope * Template
  templateOK(s, Template(lines))       :- templateLinesOK(s, lines).
  templateOK(s, TemplateSquare(lines)) :- templateLinesOK(s, lines).
  
  templateLineOK: scope * TemplateLine
  templateLineOK(s, Line(parts)) :- templatePartsOK(s, parts).
  templateLinesOK maps templateLineOK(*, list(*))
  
  templatePartOK: scope * TemplatePart
  templatePartOK(s, Angled(placeholder))  :- placeholderOK(s, placeholder).
  templatePartOK(s, Squared(placeholder)) :- placeholderOK(s, placeholder).
  templatePartOK(s, _). // Other template parts do not contain names nor types.
  templatePartsOK maps templatePartOK(*, list(*))
  
  placeholderOK: scope * Placeholder
  placeholderOK(s, Placeholder(symbol, _)) :- symbolOK(s, symbol).

//
// Template options section
//

signature

  constructors
    TemplateOptions : list(TemplateOption) -> Section
    
  sorts TemplateOption constructors
    KeywordAttributes : SymbolDef * Attributes -> TemplateOption
    // Ignore other template options, as they do not contain names nor types.
    
rules

  sectionOK(s, TemplateOptions(templateOptions)) :- templateOptionsOK(s, templateOptions).
  
  templateOptionOK: scope * TemplateOption
  templateOptionOK(s, KeywordAttributes(symbolDef, _)) :- symbolDefOK(s, symbolDef).
  templateOptionOK(s, _).
  templateOptionsOK maps templateOptionOK(*, list(*))

//
// Syntax (SDF2-style) productions sections
//

signature

  constructors
    Syntax                 : list(Production)        -> Grammar
    Lexical                : list(Production)        -> Grammar // TODO
    Contextfree            : list(Production)        -> Grammar // TODO
    Variables              : list(Production)        -> Grammar // TODO
    VariablesProductive    : list(SdfProduction)     -> Grammar // TODO
    LexVariables           : list(Production)        -> Grammar // TODO
    LexVariablesProductive : list(SdfProduction)     -> Grammar // TODO
    Kernel                 : list(SdfProduction)     -> Grammar
    LexicalSyntax          : list(SdfProduction)     -> Grammar
    ContextFreeSyntax      : list(GeneralProduction) -> Grammar
    
  sorts Production constructors // Kernel-style productions
    Prod : list(Symbol) * Symbol * Attributes -> Production

  sorts GeneralProduction constructors // General productions (explicated injection)
    GeneralProduction_SdfProduction      : SdfProduction      -> GeneralProduction
    GeneralProduction_TemplateProduction : TemplateProduction -> GeneralProduction

  sorts SdfProduction constructors // SDF2-style productions
    SdfProduction         : SymbolDef * RHS * Attributes -> SdfProduction
    SdfProductionWithCons : SortCons  * RHS * Attributes -> SdfProduction
    
  sorts RHS constructors
    Rhs : list(Symbol) -> RHS

rules

  grammarOK(s, Syntax(productions)) :- productionsOK(s, productions).
  grammarOK(s, Kernel(sdfProductions)) :- sdfProductionsOK(s, sdfProductions).
  grammarOK(s, LexicalSyntax(sdfProductions)) :- sdfProductionsOK(s, sdfProductions).
  grammarOK(s, ContextFreeSyntax(generalProductions)) :- generalProductionsOK(s, generalProductions).

  productionOK: scope * Production
  productionOK(s, Prod(symbols, symbol, _)) :-
    symbolsOK(s, symbols),
    symbolOK(s, symbol).
  productionsOK maps productionOK(*, list(*))

  generalProductionOK: scope * GeneralProduction
  generalProductionOK(s, GeneralProduction_SdfProduction(sdfProduction)) :- sdfProductionOK(s, sdfProduction).
  generalProductionOK(s, GeneralProduction_TemplateProduction(templateProduction)) :- templateProductionOK(s, templateProduction).
  generalProductionsOK maps generalProductionOK(*, list(*))

  sdfProductionOK: scope * SdfProduction
  sdfProductionOK(s, SdfProduction(symbolDef, rhs, _)) :-
    symbolDefOK(s, symbolDef),
    rhsOK(s, rhs).
  sdfProductionOK(s, SdfProductionWithCons(sortCons, rhs, _)) :-
    sortConsOK(s, sortCons),
    rhsOK(s, rhs).
  sdfProductionsOK maps sdfProductionOK(*, list(*))
  
  rhsOK: scope * RHS
  rhsOK(s, Rhs(symbols)) :- symbolsOK(s, symbols).

//
// Start symbols section
//

signature

  constructors
    KernelStartSymbols      : list(Symbol) -> Grammar
    LexicalStartSymbols     : list(Symbol) -> Grammar
    ContextFreeStartSymbols : list(Symbol) -> Grammar

rules

  grammarOK(s, KernelStartSymbols(symbols))      :- symbolsOK(s, symbols).
  grammarOK(s, LexicalStartSymbols(symbols))     :- symbolsOK(s, symbols).
  grammarOK(s, ContextFreeStartSymbols(symbols)) :- symbolsOK(s, symbols).

//
// Priorities section
//

signature

  constructors
    Priorities             : list(Priority) -> Grammar
    LexicalPriorities      : list(Priority) -> Grammar
    ContextFreePriorities  : list(Priority) -> Grammar
  
  sorts Priority constructors
    Chain : list(Group)                   -> Priority
    Assoc : Group * Associativity * Group -> Priority
    
  sorts Group constructors
    WithArguments  : Group * ArgumentIndicator                -> Group
    NonTransitive  : Group                                    -> Group
    SimpleGroup    : PriorityProduction                       -> Group
    ProdsGroup     : list(PriorityProduction)                 -> Group
    AssocGroup     : Associativity * list(PriorityProduction) -> Group
    SimpleRefGroup : SortConsRef                              -> Group
    ProdsRefGroup  : list(SortConsRef)                        -> Group
    AssocRefGroup  : Associativity * list(SortConsRef)        -> Group
    
  sorts PriorityProduction constructors
    PriorityProduction_SdfProduction : SdfProduction -> PriorityProduction
    PriorityProduction_Production    : Production    -> PriorityProduction

  sorts ArgumentIndicator
  sorts Associativity

rules

  grammarOK(s, Priorities(priorities))            :- prioritiesOK(s, priorities).
  grammarOK(s, LexicalPriorities(priorities))     :- prioritiesOK(s, priorities).
  grammarOK(s, ContextFreePriorities(priorities)) :- prioritiesOK(s, priorities).

  priorityOK: scope * Priority
  priorityOK(s, Chain(groups)) :- 
    groupsOK(s, groups).
  priorityOK(s, Assoc(group1, _, group2)) :- 
    groupOK(s, group1),
    groupOK(s, group2). 
  prioritiesOK maps priorityOK(*, list(*))
  
  groupOK: scope * Group
  groupOK(s, WithArguments(group, _))            :- groupOK(s, group).
  groupOK(s, NonTransitive(group))               :- groupOK(s, group).
  groupOK(s, SimpleGroup(priorityProduction))    :- priorityProductionOK(s, priorityProduction).
  groupOK(s, ProdsGroup(priorityProductions))    :- priorityProductionsOK(s, priorityProductions).
  groupOK(s, AssocGroup(_, priorityProductions)) :- priorityProductionsOK(s, priorityProductions).
  groupOK(s, SimpleRefGroup(sortConsRef))        :- sortConsRefOK(s, sortConsRef).
  groupOK(s, ProdsRefGroup(sortConsRefs))        :- sortConsRefsOK(s, sortConsRefs).
  groupOK(s, AssocRefGroup(_, sortConsRefs))     :- sortConsRefsOK(s, sortConsRefs).
  groupsOK maps groupOK(*, list(*))

  priorityProductionOK: scope * PriorityProduction
  // TODO: these should not declare new productions, but instead should be checked against existing ones?
  priorityProductionOK(s, PriorityProduction_SdfProduction(sdfProduction)) :- sdfProductionOK(s, sdfProduction).
  priorityProductionOK(s, PriorityProduction_Production(production))       :- productionOK(s, production).
  priorityProductionsOK maps priorityProductionOK(*, list(*))

//
// Restrictions section
//

signature

  constructors
    Restrictions            : list(Restriction) -> Grammar
    LexicalRestrictions     : list(Restriction) -> Grammar
    ContextFreeRestrictions : list(Restriction) -> Grammar
    
  sorts Restriction constructors
    Follow : list(Symbol) * Lookaheads -> Restriction
    
  sorts Lookaheads

rules

  grammarOK(s, Restrictions(restrictions))            :- restrictionsOK(s, restrictions).
  grammarOK(s, LexicalRestrictions(restrictions))     :- restrictionsOK(s, restrictions).
  grammarOK(s, ContextFreeRestrictions(restrictions)) :- restrictionsOK(s, restrictions).
  
  restrictionOK: scope * Restriction
  restrictionOK(s, Follow(symbols, _)) :- symbolsOK(s, symbols).
  restrictionsOK maps restrictionOK(*, list(*))

//
// Sorts section
//

signature

  constructors
    Sorts : list(DeclSymbol) -> Grammar

  sorts DeclSymbol constructors
    DeclSort    : string     -> DeclSymbol
    DeclSortCf  : DeclSymbol -> DeclSymbol
    DeclSortLex : DeclSymbol -> DeclSymbol
    DeclSortVar : DeclSymbol -> DeclSymbol

rules

  grammarOK(s, Sorts(declSymbols)) :- declSymbolsOK(s, declSymbols).

  declSymbolOK: scope * DeclSymbol
  declSymbolOK(s, DeclSort(name))         :- resolveSort(s, name).
  declSymbolOK(s, DeclSortCf(symbolDef))  :- declSymbolOK(s, symbolDef).
  declSymbolOK(s, DeclSortLex(symbolDef)) :- declSymbolOK(s, symbolDef).
  declSymbolOK(s, DeclSortVar(symbolDef)) :- declSymbolOK(s, symbolDef).
  declSymbolsOK maps declSymbolOK(*, list(*))

//
// Aliases section
//


signature

  constructors
    Aliases : list(Alias) -> Grammar
    
  sorts Alias constructors
    Alias : Symbol * Symbol -> Alias
    
rules

  grammarOK(s, Aliases(aliases)) :- aliasesOK(s, aliases).
  
  // TODO: what are the static semantics of an alias? Does it declare the symbol on the right-hand side?
  aliasOK: scope * Alias
  aliasOK(s, Alias(symbol1, symbol2)) :-
    symbolOK(s, symbol1),
    symbolOK(s, symbol2).
  aliasesOK maps aliasOK(*, list(*))

//
// Sorts and Constructors
//

signature

  sorts SortCons constructors
    SortCons : SymbolDef * Constructor -> SortCons
    
  sorts Constructor constructors
    Constructor : string -> Constructor
    
  sorts SymbolDef constructors
    SortDef      : string    -> SymbolDef
    SymbolDefCf  : SymbolDef -> SymbolDef
    SymbolDefLex : SymbolDef -> SymbolDef
    SymbolDefVar : SymbolDef -> SymbolDef

  sorts SortConsRef constructors
    SortConsRef : Symbol * Constructor -> SortConsRef

rules

  sortConsOK: scope * SortCons
  sortConsOK(s, SortCons(symbolDef, constructor)) :-
    symbolDefOK(s, symbolDef),
    constructorDefOK(s, constructor).
  
  constructorDefOK: scope * Constructor
  constructorDefOK(s, Constructor(name)) :-
    declareConstructor(s, name).

  constructorRefOK: scope * Constructor
  constructorRefOK(s, Constructor(name)) :-
    resolveConstructor(s, name).

  symbolDefOK: scope * SymbolDef
  symbolDefOK(s, SortDef(name))            :- declareSort(s, name).
  symbolDefOK(s, SymbolDefCf(symbolDef))   :- symbolDefOK(s, symbolDef).
  symbolDefOK(s, SymbolDefLex(symbolDef))  :- symbolDefOK(s, symbolDef).
  symbolDefOK(s, SymbolDefVar(symbolDef)) :- symbolDefOK(s, symbolDef).

  sortConsRefOK: scope * SortConsRef
  sortConsRefOK(s, SortConsRef(symbol, constructor)) :-
    symbolOK(s, symbol),
    constructorRefOK(s, constructor).
  sortConsRefsOK maps sortConsRefOK(*, list(*))

rules // Sort reusable predicates

  declareSort : scope * string  
  declareSort(s, name) :-
    s -> Sort{name}.
    
  resolveSort : scope * string
  resolveSort(s, name)  :- {name'}
    Sort{name} in s |-> [(_, (Sort{name'}))|_]| error $[Sort [name] not defined],
    @name.ref := name'.

rules // Constructor reusable predicates

  // TODO: constructors should be typed as sort -> sort*, and they must be unique within that name+type.

  declareConstructor : scope * string  
  declareConstructor(s, name) :-
    s -> Constructor{name},
    Constructor{name} in s |-> [(_, (_))] | error $[Duplicate definition of constructor [name]].
    
  resolveConstructor : scope * string
  resolveConstructor(s, name)  :- {name'}
    Constructor{name} in s |-> [(_, (Constructor{name'}))|_]| error $[Constructor [name] not defined],
    @name.ref := name'.

//
// Symbols
//

signature

  sorts Symbol constructors
    Cf                : Symbol                -> Symbol
    Lex               : Symbol                -> Symbol
    Varsym            : Symbol                -> Symbol
    Label             : Label  * Symbol       -> Symbol
    Sequence          : Symbol * Symbol       -> Symbol
    Opt               : Symbol                -> Symbol
    Iter              : Symbol                -> Symbol
    IterStar          : Symbol                -> Symbol
    IterSep           : Symbol * Separator    -> Symbol
    IterStarSep       : Symbol * Separator    -> Symbol
    Alt               : Symbol * Symbol       -> Symbol
    Sort              : string                -> Symbol
    ParameterizedSort : string * list(Symbol) -> Symbol

  sorts Separator

rules

  symbolOK: scope * Symbol
  symbolOK(s, Cf(symbol))                       :- symbolOK(s, symbol).
  symbolOK(s, Lex(symbol))                      :- symbolOK(s, symbol).
  symbolOK(s, Varsym(symbol))                   :- symbolOK(s, symbol).
  symbolOK(s, Label(label, symbol))             :-
    labelOK(s, label), 
    symbolOK(s, symbol).
  symbolOK(s, Sequence(symbol1, symbol2))       :- 
    symbolOK(s, symbol1), 
    symbolOK(s, symbol2).
  symbolOK(s, Opt(symbol))                      :- symbolOK(s, symbol).
  symbolOK(s, Iter(symbol))                     :- symbolOK(s, symbol).
  symbolOK(s, IterStar(symbol))                 :- symbolOK(s, symbol).
  symbolOK(s, IterSep(symbol, _))               :- symbolOK(s, symbol).
  symbolOK(s, IterStarSep(symbol, _))           :- symbolOK(s, symbol).
  symbolOK(s, Alt(symbol1, symbol2))            :- 
    symbolOK(s, symbol1), 
    symbolOK(s, symbol2).
  symbolOK(s, Sort(name))                       :- resolveSort(s, name).
  symbolOK(s, ParameterizedSort(name, symbols)) :- 
    resolveSort(s, name), 
    symbolsOK(s, symbols).
  symbolOK(s, _).
  symbolsOK maps symbolOK(*, list(*))


//
// Labels
//

signature

  sorts Label constructors
    Quoted   : string -> Label
    Unquoted : string -> Label

rules

  labelOK: scope * Label
  labelOK(s, Quoted(name))   :- declareLabel(s, name).
  labelOK(s, Unquoted(name)) :- declareLabel(s, name).

rules // Label reusable predicates

  declareLabel : scope * string  
  declareLabel(s, name) :-
    s -> Label{name}.
    
  resolveLabel : scope * string
  resolveLabel(s, name)  :- {name'}
    Label{name} in s |-> [(_, (Sort{name'}))|_]| error $[Label [name] not defined],
    @name.ref := name'.

